{
  "version": 3,
  "sources": ["../../../../../../node_modules/.pnpm/tiny-warning@1.0.3/node_modules/tiny-warning/dist/tiny-warning.esm.js", "../../../../../../node_modules/.pnpm/@angular+core@19.2.4_rxjs@7.8.1_zone.js@0.15.0/node_modules/@angular/core/fesm2022/rxjs-interop.mjs", "../../../../../../packages/angular-router/src/distinct-until-ref-changed.ts", "../../../../../../packages/angular-router/src/default-not-found.ts", "../../../../../../packages/angular-router/src/is-dev-mode.ts", "../../../../../../packages/angular-router/src/router.ts", "../../../../../../packages/angular-router/src/router-state.ts", "../../../../../../packages/angular-router/src/outlet.ts", "../../../../../../packages/angular-router/src/match.ts", "../../../../../../packages/angular-router/src/loader-data.ts", "../../../../../../packages/angular-router/src/loader-deps.ts", "../../../../../../packages/angular-router/src/params.ts", "../../../../../../packages/angular-router/src/route-context.ts", "../../../../../../packages/angular-router/src/search.ts", "../../../../../../packages/angular-router/src/route.ts", "../../../../../../packages/angular-router/src/default-error.ts", "../../../../../../packages/angular-router/src/transitioner.ts", "../../../../../../packages/angular-router/src/matches.ts", "../../../../../../packages/angular-router/src/link.ts", "../../../../../../packages/angular-router/src/match-route.ts", "../../../../../../packages/angular-router/src/file-route.ts", "../../../../../../packages/angular-router/src/router-root.ts", "../../../../../../packages/angular-router/src/can-go-back.ts", "../../../../../../packages/angular-router/src/location.ts", "../../../../../../packages/angular-router/src/tanstack-angular-router.ts"],
  "sourcesContent": ["var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n    var text = \"Warning: \" + message;\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\nexport default warning;", "/**\n * @license Angular v19.2.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError as _RuntimeError, ɵgetOutputDestroyRef as _getOutputDestroyRef, Injector, effect, untracked, ɵmicrotaskEffect as _microtaskEffect, assertNotInReactiveContext, signal, computed, PendingTasks, resource } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @publicApi\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n  source;\n  destroyed = false;\n  destroyRef = inject(DestroyRef);\n  constructor(source) {\n    this.source = source;\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n  subscribe(callbackFn) {\n    if (this.destroyed) {\n      throw new _RuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\n    }\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: value => callbackFn(value)\n    });\n    return {\n      unsubscribe: () => subscription.unsubscribe()\n    };\n  }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @publicApi\n */\nfunction outputFromObservable(observable, opts) {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @publicApi\n */\nfunction outputToObservable(ref) {\n  const destroyRef = _getOutputDestroyRef(ref);\n  return new Observable(observer => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    destroyRef?.onDestroy(() => observer.complete());\n    const subscription = ref.subscribe(v => observer.next(v));\n    return () => subscription.unsubscribe();\n  });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\nfunction toObservableMicrotask(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = _microtaskEffect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n  ngDevMode && assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' + 'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  const equal = makeToSignalEqual(options?.equal);\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({\n      kind: 0 /* StateKind.NoValue */\n    }, {\n      equal\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    }, {\n      equal\n    });\n  }\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: value => state.set({\n      kind: 1 /* StateKind.Value */,\n      value\n    }),\n    error: error => {\n      if (options?.rejectErrors) {\n        // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n        // the error to end up as an uncaught exception.\n        throw error;\n      }\n      state.set({\n        kind: 2 /* StateKind.Error */,\n        error\n      });\n    }\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n  if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n    throw new _RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        throw new _RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  }, {\n    equal: options?.equal\n  });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n  return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\n}\n\n/**\n * Operator which makes the application unstable until the observable emits, complets, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @experimental\n */\nfunction pendingUntilEvent(injector) {\n  if (injector === undefined) {\n    assertInInjectionContext(pendingUntilEvent);\n    injector = inject(Injector);\n  }\n  const taskService = injector.get(PendingTasks);\n  return sourceObservable => {\n    return new Observable(originalSubscriber => {\n      // create a new task on subscription\n      const removeTask = taskService.add();\n      let cleanedUp = false;\n      function cleanupTask() {\n        if (cleanedUp) {\n          return;\n        }\n        removeTask();\n        cleanedUp = true;\n      }\n      const innerSubscription = sourceObservable.subscribe({\n        next: v => {\n          originalSubscriber.next(v);\n          cleanupTask();\n        },\n        complete: () => {\n          originalSubscriber.complete();\n          cleanupTask();\n        },\n        error: e => {\n          originalSubscriber.error(e);\n          cleanupTask();\n        }\n      });\n      innerSubscription.add(() => {\n        originalSubscriber.unsubscribe();\n        cleanupTask();\n      });\n      return innerSubscription;\n    });\n  };\n}\nfunction rxResource(opts) {\n  opts?.injector || assertInInjectionContext(rxResource);\n  return resource({\n    ...opts,\n    loader: undefined,\n    stream: params => {\n      let sub;\n      // Track the abort listener so it can be removed if the Observable completes (as a memory\n      // optimization).\n      const onAbort = () => sub.unsubscribe();\n      params.abortSignal.addEventListener('abort', onAbort);\n      // Start off stream as undefined.\n      const stream = signal({\n        value: undefined\n      });\n      let resolve;\n      const promise = new Promise(r => resolve = r);\n      function send(value) {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = undefined;\n      }\n      sub = opts.loader(params).subscribe({\n        next: value => send({\n          value\n        }),\n        error: error => send({\n          error\n        }),\n        complete: () => {\n          if (resolve) {\n            send({\n              error: new Error('Resource completed before producing a value')\n            });\n          }\n          params.abortSignal.removeEventListener('abort', onAbort);\n        }\n      });\n      return promise;\n    }\n  });\n}\nexport { outputFromObservable, outputToObservable, pendingUntilEvent, rxResource, takeUntilDestroyed, toObservable, toSignal, toObservableMicrotask as ɵtoObservableMicrotask };\n", "import { distinctUntilChanged } from 'rxjs'\n\nexport function distinctUntilRefChanged<T>() {\n  return distinctUntilChanged<T>(Object.is)\n}\n", "import { ChangeDetectionStrategy, Component } from '@angular/core'\n\n@Component({\n  selector: 'default-not-found,DefaultNotFound',\n  template: ` <p>Page not found</p> `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: { style: 'display: contents;' },\n})\nexport class DefaultNotFound {}\n", "import { DOCUMENT } from '@angular/common'\nimport {\n  Injector,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\n\nexport function isDevMode({ injector }: { injector?: Injector } = {}) {\n  !injector && assertInInjectionContext(isDevMode)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    const document = inject(DOCUMENT)\n    const window = document.defaultView\n    return !!window && 'ng' in window\n  })\n}\n", "import {\n  ApplicationRef,\n  InjectionToken,\n  Injector,\n  createEnvironmentInjector,\n  inject,\n} from '@angular/core'\nimport { RouterCore, rootRouteId } from '@tanstack/router-core'\nimport { BehaviorSubject } from 'rxjs'\n\nimport type {\n  AnyRoute,\n  AnyRouter,\n  CreateRouterFn,\n  RouterConstructorOptions,\n  RouterState,\n  TrailingSlashOption,\n} from '@tanstack/router-core'\nimport type { Observable } from 'rxjs'\nimport type { EnvironmentInjector, Provider } from '@angular/core'\nimport type { HistoryLocation, RouterHistory } from '@tanstack/history'\nimport type { RouteComponent } from './route'\n\ndeclare module '@tanstack/history' {\n  interface HistoryState {\n    __tempLocation?: HistoryLocation\n    __tempKey?: string\n    __hashScrollIntoViewOptions?: boolean | ScrollIntoViewOptions\n  }\n}\n\ndeclare module '@tanstack/router-core' {\n  export interface RouterOptionsExtensions {\n    /**\n     * The default `component` a route should use if no component is provided.\n     *\n     * @default Outlet\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultcomponent-property)\n     */\n    defaultComponent?: () => RouteComponent\n    /**\n     * The default `errorComponent` a route should use if no error component is provided.\n     *\n     * @default ErrorComponent\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaulterrorcomponent-property)\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/data-loading#handling-errors-with-routeoptionserrorcomponent)\n     */\n    defaultErrorComponent?: () => RouteComponent\n    /**\n     * The default `pendingComponent` a route should use if no pending component is provided.\n     *\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultpendingcomponent-property)\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/data-loading#showing-a-pending-component)\n     */\n    defaultPendingComponent?: () => RouteComponent\n    /**\n     * The default `notFoundComponent` a route should use if no notFound component is provided.\n     *\n     * @default NotFound\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/solid/api/router/RouterOptionsType#defaultnotfoundcomponent-property)\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/solid/guide/not-found-errors#default-router-wide-not-found-handling)\n     */\n    defaultNotFoundComponent?: () => RouteComponent\n    /**\n     * The default `onCatch` handler for errors caught by the Router ErrorBoundary\n     *\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultoncatch-property)\n     * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#handling-errors-with-routeoptionsoncatch)\n     */\n    defaultOnCatch?: (error: Error) => void\n  }\n}\n\nexport const ROUTER = new InjectionToken<NgRouter<AnyRoute>>('ROUTER')\nexport const ROUTER_STATE = new InjectionToken<\n  Observable<RouterState<AnyRoute>>\n>('ROUTER_STATE')\n\nexport function injectRouter() {\n  return inject(ROUTER)\n}\n\nexport function injectRouterState() {\n  return inject(ROUTER_STATE)\n}\n\nexport function provideRouter(router: AnyRouter) {\n  return [\n    { provide: ROUTER, useValue: router },\n    {\n      provide: ROUTER_STATE,\n      useFactory: () => {\n        const state = new BehaviorSubject(router.state)\n        const appRef = inject(ApplicationRef)\n\n        const unsub = router.__store.subscribe(({ currentVal }) => {\n          state.next(currentVal)\n        })\n\n        appRef.onDestroy(() => {\n          state.complete()\n          unsub()\n        })\n\n        return state.asObservable()\n      },\n    },\n  ]\n}\n\nexport const createRouter: CreateRouterFn = (options) => {\n  return new NgRouter(options)\n}\n\nexport class NgRouter<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption = 'never',\n  in out TDefaultStructuralSharingOption extends boolean = false,\n  in out TRouterHistory extends RouterHistory = RouterHistory,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n> extends RouterCore<\n  TRouteTree,\n  TTrailingSlashOption,\n  TDefaultStructuralSharingOption,\n  TRouterHistory,\n  TDehydrated\n> {\n  private injectors = new Map<string, Injector>()\n  private envInjectors = new Map<string, EnvironmentInjector>()\n\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n  ) {\n    super(options)\n  }\n\n  getRouteInjector(\n    routeId: string,\n    parent: Injector,\n    providers: Array<Provider> = [],\n  ) {\n    const existingInjector = this.injectors.get(routeId)\n    if (existingInjector) return existingInjector\n\n    const injector = Injector.create({\n      providers,\n      parent,\n      name: routeId,\n    })\n\n    // cache\n    this.injectors.set(routeId, injector)\n    return injector\n  }\n\n  getRouteEnvInjector(\n    routeId: string,\n    parent: EnvironmentInjector,\n    providers: Array<Provider> = [],\n    router: AnyRouter,\n  ) {\n    const existingInjector = this.envInjectors.get(routeId)\n    if (existingInjector) return existingInjector\n\n    let route = router.routesById[routeId] || router.routesByPath[routeId]\n\n    // walk up the route hierarchy to build the providers\n    while (route) {\n      if (route.options?.providers) {\n        providers.push(...route.options.providers)\n      }\n\n      const parentInjector = route.parentRoute\n        ? this.envInjectors.get(route.parentRoute.id)\n        : null\n\n      if (parentInjector) {\n        parent = parentInjector\n        break\n      }\n\n      route = route.parentRoute\n    }\n\n    const envInjector = createEnvironmentInjector(providers, parent, routeId)\n\n    // if routeId is rootRouteId, we'll switch existing injectors' parent to the __root__ injector\n    if (routeId === rootRouteId) {\n      this.envInjectors.forEach((ele) => {\n        if ('parent' in ele && ele.parent === parent) {\n          ele.parent = envInjector\n        }\n      })\n    }\n\n    // cache\n    this.envInjectors.set(routeId, envInjector)\n    return envInjector\n  }\n}\n", "import {\n  Injector,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toSignal } from '@angular/core/rxjs-interop'\nimport { shallow } from '@tanstack/router-core'\nimport { distinctUntilChanged, map } from 'rxjs'\nimport { injectRouterState } from './router'\n\nimport type { Observable } from 'rxjs'\n\nimport type { Signal, ValueEqualityFn } from '@angular/core'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  RouterState,\n} from '@tanstack/router-core'\n\nexport type RouterStateResult<\n  TRouter extends AnyRouter,\n  TSelected,\n> = unknown extends TSelected ? RouterState<TRouter['routeTree']> : TSelected\n\nexport type RouterStateOptions<TRouter extends AnyRouter, TSelected> = {\n  select?: (state: RouterState<TRouter['routeTree']>) => TSelected\n  equal?: ValueEqualityFn<\n    RouterStateResult<NoInfer<TRouter>, NoInfer<TSelected>>\n  >\n  injector?: Injector\n}\n\nexport function routerState$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>({\n  select,\n  injector,\n  equal = shallow,\n}: RouterStateOptions<TRouter, TSelected>): Observable<\n  RouterStateResult<TRouter, TSelected>\n> {\n  !injector && assertInInjectionContext(routerState$)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    const rootRouterState = injectRouterState()\n    if (select)\n      return rootRouterState.pipe(\n        map((s) => select(s) as any),\n        distinctUntilChanged(equal),\n      )\n    return rootRouterState.pipe(distinctUntilChanged(equal) as any)\n  })\n}\n\nexport function routerState<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>({\n  select,\n  injector,\n  equal = shallow,\n}: RouterStateOptions<TRouter, TSelected> = {}): Signal<\n  RouterStateResult<TRouter, TSelected>\n> {\n  !injector && assertInInjectionContext(routerState)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () =>\n    toSignal(routerState$({ select, injector, equal }), { injector }),\n  ) as Signal<RouterStateResult<TRouter, TSelected>>\n}\n", "import {\n  ChangeDetectionStrategy,\n  Component,\n  DestroyRef,\n  Directive,\n  EnvironmentInjector,\n  InjectionToken,\n  Injector,\n  ViewContainerRef,\n  afterNextRender,\n  inject,\n  input,\n} from '@angular/core'\nimport { toObservable } from '@angular/core/rxjs-interop'\nimport {\n  createControlledPromise,\n  getLocationChangeInfo,\n  isNotFound,\n  isRedirect,\n  pick,\n  rootRouteId,\n} from '@tanstack/router-core'\nimport {\n  catchError,\n  combineLatest,\n  distinctUntilChanged,\n  filter,\n  map,\n  of,\n  switchMap,\n  take,\n  throwError,\n  withLatestFrom,\n} from 'rxjs'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { DefaultError } from './default-error'\nimport { DefaultNotFound } from './default-not-found'\nimport { distinctUntilRefChanged } from './distinct-until-ref-changed'\nimport { isDevMode } from './is-dev-mode'\nimport { ERROR_COMPONENT_CONTEXT, NOT_FOUND_COMPONENT_CONTEXT } from './route'\nimport { injectRouter } from './router'\nimport { routerState$ } from './router-state'\n\nimport type { ComponentRef, Type } from '@angular/core'\nimport type { Subscription } from 'rxjs'\n\n@Directive()\nexport class OnRendered {\n  private match = inject(RouteMatch)\n  private router = injectRouter()\n\n  private parentRouteId$ = combineLatest([\n    this.match.matchId$,\n    routerState$({ select: (s) => s.matches }),\n  ]).pipe(\n    map(\n      ([matchId, matches]) =>\n        matches.find((d) => d.id === matchId)?.routeId as string,\n    ),\n    distinctUntilRefChanged(),\n  )\n  private location$ = routerState$({\n    select: (s) => s.resolvedLocation?.state.key,\n  })\n\n  constructor() {\n    let subscription: Subscription\n    afterNextRender(() => {\n      subscription = combineLatest([\n        this.parentRouteId$,\n        this.location$,\n      ]).subscribe(([parentRouteId]) => {\n        if (!parentRouteId || parentRouteId !== rootRouteId) return\n        this.router.emit({\n          type: 'onRendered',\n          ...getLocationChangeInfo(this.router.state),\n        })\n      })\n    })\n\n    inject(DestroyRef).onDestroy(() => {\n      subscription.unsubscribe()\n    })\n  }\n}\n\nexport const MATCH_ID = new InjectionToken<string>('MATCH_ID')\n\n@Component({\n  selector: 'route-match,RouteMatch',\n  template: ``,\n  hostDirectives: [OnRendered],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    '[attr.data-matchId]': 'matchId()',\n  },\n})\nexport class RouteMatch {\n  matchId = input.required<string>()\n\n  private isDevMode = isDevMode()\n  private router = injectRouter()\n  private vcr = inject(ViewContainerRef)\n  private injector = inject(Injector)\n  private environmentInjector = inject(EnvironmentInjector)\n\n  matchId$ = toObservable(this.matchId)\n  private resetKey$ = routerState$({ select: (s) => s.loadedAt.toString() })\n  private matches$ = routerState$({ select: (s) => s.matches })\n  private routeId$ = combineLatest([this.matchId$, this.matches$]).pipe(\n    map(\n      ([matchId, matches]) =>\n        matches.find((d) => d.id === matchId)?.routeId as string,\n    ),\n    distinctUntilRefChanged(),\n  )\n\n  private route$ = this.routeId$.pipe(\n    map((routeId) => this.router.routesById[routeId]),\n    distinctUntilRefChanged(),\n  )\n  private pendingComponent$ = this.route$.pipe(\n    map(\n      (route) =>\n        route.options.pendingComponent ||\n        this.router.options.defaultPendingComponent,\n    ),\n    distinctUntilRefChanged(),\n  )\n  private errorComponent$ = this.route$.pipe(\n    map(\n      (route) =>\n        route.options.errorComponent ||\n        this.router.options.defaultErrorComponent,\n    ),\n    distinctUntilRefChanged(),\n  )\n  private onCatch$ = this.route$.pipe(\n    map((route) => route.options.onCatch || this.router.options.defaultOnCatch),\n    distinctUntilRefChanged(),\n  )\n\n  private matchIndex$ = combineLatest([this.matchId$, this.matches$]).pipe(\n    map(([matchId, matches]) => matches.findIndex((d) => d.id === matchId)),\n    distinctUntilRefChanged(),\n  )\n  private matchState$ = combineLatest([this.matchIndex$, this.matches$]).pipe(\n    map(([matchIndex, matches]) => matches[matchIndex]),\n    filter((match) => !!match),\n    map((match) => ({\n      routeId: match.routeId as string,\n      match: pick(match, ['id', 'status', 'error']),\n    })),\n  )\n\n  private matchRoute$ = this.matchState$.pipe(\n    map(({ routeId }) => this.router.routesById[routeId]),\n    distinctUntilRefChanged(),\n  )\n  private match$ = this.matchState$.pipe(\n    map(({ match }) => match),\n    distinctUntilChanged((a, b) => a.id === b.id && a.status === b.status),\n  )\n  private matchLoad$ = this.match$.pipe(\n    withLatestFrom(this.matchRoute$),\n    switchMap(([match, matchRoute]) => {\n      const loadPromise = this.router.getMatch(match.id)?.loadPromise\n      if (!loadPromise) return Promise.resolve() as any\n\n      if (match.status === 'pending') {\n        const pendingMinMs =\n          matchRoute.options.pendingMinMs ??\n          this.router.options.defaultPendingMinMs\n        let minPendingPromise = this.router.getMatch(\n          match.id,\n        )?.minPendingPromise\n\n        if (pendingMinMs && !minPendingPromise) {\n          // Create a promise that will resolve after the minPendingMs\n          if (!this.router.isServer) {\n            minPendingPromise = createControlledPromise<void>()\n            Promise.resolve().then(() => {\n              this.router.updateMatch(match.id, (prev) => ({\n                ...prev,\n                minPendingPromise,\n              }))\n            })\n\n            setTimeout(() => {\n              minPendingPromise?.resolve()\n              // We've handled the minPendingPromise, so we can delete it\n              this.router.updateMatch(match.id, (prev) => ({\n                ...prev,\n                minPendingPromise: undefined,\n              }))\n            }, pendingMinMs)\n          }\n        }\n\n        return minPendingPromise?.then(() => loadPromise) || loadPromise\n      }\n\n      return loadPromise\n    }),\n    distinctUntilRefChanged(),\n  )\n\n  private run$ = this.routeId$.pipe(\n    switchMap((routeId) => {\n      invariant(\n        routeId,\n        `Could not find routeId for matchId \"${this.matchId()}\". Please file an issue!`,\n      )\n      return combineLatest([\n        this.match$,\n        this.matchRoute$,\n        this.resetKey$,\n      ]).pipe(\n        switchMap(([match, route]) => {\n          if (match.status === 'notFound') {\n            invariant(isNotFound(match.error), 'Expected a notFound error')\n            let notFoundCmp: Type<any> | undefined\n            if (!route.options.notFoundComponent) {\n              notFoundCmp = this.router.options.defaultNotFoundComponent?.()\n              if (!notFoundCmp) {\n                if (this.isDevMode) {\n                  warning(\n                    route.options.notFoundComponent,\n                    `A notFoundError was encountered on the route with ID \"${route.id}\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<p>Page not found</p>)`,\n                  )\n                }\n                notFoundCmp = DefaultNotFound\n              }\n            } else {\n              notFoundCmp = route.options.notFoundComponent()\n            }\n\n            const injector = this.router.getRouteInjector(\n              route.id + '-not-found',\n              this.injector,\n              [{ provide: NOT_FOUND_COMPONENT_CONTEXT, useValue: {} }],\n            )\n            return of({\n              component: notFoundCmp,\n              injector,\n              environmentInjector: null,\n              clearView: true,\n            } as const)\n          }\n\n          if (match.status === 'redirected' || match.status === 'pending') {\n            if (match.status === 'redirected') {\n              invariant(isRedirect(match.error), 'Expected a redirect error')\n            }\n\n            return this.matchLoad$.pipe(\n              withLatestFrom(this.pendingComponent$),\n              switchMap(([, pendingComponent]) => {\n                const pendingCmp = pendingComponent?.()\n                if (!pendingCmp) return of(null)\n                return of({\n                  component: pendingCmp,\n                  injector: null,\n                  environmentInjector: null,\n                  clearView: true,\n                } as const)\n              }),\n            )\n          }\n\n          if (match.status === 'error') {\n            return this.errorComponent$.pipe(\n              take(1),\n              switchMap((errorComponent) => {\n                const errorCmp = errorComponent?.() || DefaultError\n                const injector = this.router.getRouteInjector(\n                  route.id + '-error',\n                  this.injector,\n                  [\n                    {\n                      provide: ERROR_COMPONENT_CONTEXT,\n                      useValue: {\n                        error: match.error,\n                        info: { componentStack: '' },\n                        reset: () => void this.router.invalidate(),\n                      },\n                    },\n                  ],\n                )\n                return of({\n                  component: errorCmp,\n                  injector,\n                  environmentInjector: null,\n                  clearView: true,\n                } as const)\n              }),\n            )\n          }\n\n          const successComponent = route.options.component?.() || Outlet\n\n          if (this.cmp === successComponent) {\n            return of({ clearView: false } as const)\n          }\n\n          this.cmpRef = undefined\n          this.cmp = successComponent\n          const injector = this.router.getRouteInjector(route.id, this.injector)\n          const environmentInjector = this.router.getRouteEnvInjector(\n            route.id,\n            this.environmentInjector,\n            route.options.providers || [],\n            this.router,\n          )\n\n          return of({\n            component: successComponent,\n            injector: Injector.create({\n              providers: [{ provide: MATCH_ID, useValue: match.id }],\n              parent: injector,\n            }),\n            environmentInjector,\n            clearView: true,\n          } as const)\n        }),\n      )\n    }),\n    catchError((error) =>\n      this.onCatch$.pipe(\n        take(1),\n        switchMap((onCatch) => throwError(() => [error, onCatch])),\n      ),\n    ),\n  )\n\n  private cmp?: Type<any>\n  private cmpRef?: ComponentRef<any>\n\n  constructor() {\n    let subscription: Subscription\n\n    afterNextRender(() => {\n      subscription = this.run$.subscribe({\n        next: (runData) => {\n          if (!runData) return\n          if (!runData.clearView) {\n            this.cmpRef?.changeDetectorRef.markForCheck()\n            return\n          }\n          const { component, injector, environmentInjector } = runData\n          this.vcr.clear()\n\n          this.cmpRef = this.vcr.createComponent(component, {\n            injector: injector || undefined,\n            environmentInjector: environmentInjector || undefined,\n          })\n          this.cmpRef.changeDetectorRef.markForCheck()\n        },\n        error: (error) => {\n          if (Array.isArray(error)) {\n            const [errorToThrow, onCatch] = error\n            if (onCatch) onCatch(errorToThrow)\n            console.error(errorToThrow)\n            return\n          }\n          console.error(error)\n        },\n      })\n    })\n\n    inject(DestroyRef).onDestroy(() => {\n      subscription.unsubscribe()\n      this.vcr.clear()\n      this.cmp = undefined\n      this.cmpRef = undefined\n    })\n  }\n}\n\n@Component({\n  selector: 'outlet,Outlet',\n  template: ``,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class Outlet {\n  private matchId = inject(MATCH_ID)\n  private router = injectRouter()\n  private vcr = inject(ViewContainerRef)\n  private isDevMode = isDevMode()\n\n  protected readonly defaultPendingComponent =\n    this.router.options.defaultPendingComponent?.()\n\n  private matches$ = routerState$({ select: (s) => s.matches })\n  private routeId$ = this.matches$.pipe(\n    map(\n      (matches) =>\n        matches.find((d) => d.id === this.matchId)?.routeId as string,\n    ),\n    distinctUntilRefChanged(),\n  )\n  private route$ = this.routeId$.pipe(\n    map((routeId) => this.router.routesById[routeId]),\n    distinctUntilRefChanged(),\n  )\n  private parentGlobalNotFound$ = this.matches$.pipe(\n    map((matches) => {\n      const parentMatch = matches.find((d) => d.id === this.matchId)\n      if (!parentMatch) {\n        warning(\n          false,\n          `Could not find parent match for matchId \"${this.matchId}\". Please file an issue!`,\n        )\n        return false\n      }\n      return parentMatch.globalNotFound\n    }),\n  )\n\n  private childMatchId$ = this.matches$.pipe(\n    map((matches) => {\n      const index = matches.findIndex((d) => d.id === this.matchId)\n      if (index === -1) return null\n      return matches[index + 1]?.id\n    }),\n    distinctUntilRefChanged(),\n  )\n  private matchLoad$ = this.childMatchId$.pipe(\n    switchMap((childMatchId) => {\n      if (!childMatchId) return Promise.resolve() as any\n      const loadPromise = this.router.getMatch(childMatchId)?.loadPromise\n      if (!loadPromise) return Promise.resolve() as any\n      return loadPromise\n    }),\n  )\n\n  private renderedId?: string\n  private cmpRef?: ComponentRef<any>\n\n  private run$ = combineLatest([\n    this.parentGlobalNotFound$,\n    this.childMatchId$,\n  ]).pipe(\n    switchMap(([parentGlobalNotFound, childMatchId]) => {\n      if (parentGlobalNotFound) {\n        return this.route$.pipe(\n          map((route) => {\n            let notFoundCmp: Type<any> | undefined = undefined\n\n            if (!route.options.notFoundComponent) {\n              notFoundCmp = this.router.options.defaultNotFoundComponent?.()\n              if (!notFoundCmp) {\n                if (this.isDevMode) {\n                  warning(\n                    route.options.notFoundComponent,\n                    `A notFoundError was encountered on the route with ID \"${route.id}\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<p>Page not found</p>)`,\n                  )\n                }\n                notFoundCmp = DefaultNotFound\n              }\n            } else {\n              notFoundCmp = route.options.notFoundComponent()\n            }\n\n            this.renderedId = route.id + '-not-found'\n            const injector = this.router.getRouteInjector(\n              route.id + '-not-found',\n              this.vcr.injector,\n              [{ provide: NOT_FOUND_COMPONENT_CONTEXT, useValue: {} }],\n            )\n            return {\n              component: notFoundCmp,\n              injector,\n              clearView: true,\n              childMatchId: null,\n            } as const\n          }),\n        )\n      }\n\n      if (!childMatchId) return of(null)\n\n      if (this.renderedId === childMatchId) {\n        return of({ clearView: false } as const)\n      }\n\n      this.cmpRef = undefined\n\n      if (childMatchId === rootRouteId) {\n        return this.matchLoad$.pipe(\n          map(() => {\n            return {\n              component: this.defaultPendingComponent,\n              injector: null,\n              clearView: true,\n              childMatchId: null,\n            } as const\n          }),\n        )\n      }\n\n      this.renderedId = childMatchId\n      return of({\n        component: RouteMatch,\n        injector: null,\n        clearView: true,\n        childMatchId,\n      } as const)\n    }),\n    catchError((error) => throwError(() => error)),\n  )\n\n  constructor() {\n    let subscription: Subscription\n    afterNextRender(() => {\n      subscription = this.run$.subscribe({\n        next: (runData) => {\n          if (!runData) return\n          if (!runData.clearView) {\n            this.cmpRef?.changeDetectorRef.markForCheck()\n            return\n          }\n          const { component, injector, childMatchId } = runData\n          this.vcr.clear()\n          if (!component) return\n          this.cmpRef = this.vcr.createComponent(component, {\n            injector: injector || undefined,\n          })\n          if (childMatchId) {\n            this.cmpRef.setInput('matchId', childMatchId)\n          }\n          this.cmpRef.changeDetectorRef.markForCheck()\n        },\n        error: (error) => {\n          console.error(error)\n        },\n      })\n    })\n\n    inject(DestroyRef).onDestroy(() => {\n      subscription.unsubscribe()\n      this.vcr.clear()\n      this.cmpRef = undefined\n      this.renderedId = undefined\n    })\n  }\n}\n", "import {\n  Injector,\n  assertInInjectionContext,\n  computed,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toObservable, toSignal } from '@angular/core/rxjs-interop'\nimport { combineLatest, map } from 'rxjs'\nimport invariant from 'tiny-invariant'\nimport { MATCH_ID } from './outlet'\nimport { routerState$ } from './router-state'\n\nimport type { Observable } from 'rxjs'\nimport type {\n  AnyRouter,\n  MakeRouteMatch,\n  MakeRouteMatchUnion,\n  RegisteredRouter,\n  StrictOrFrom,\n  ThrowConstraint,\n  ThrowOrOptional,\n} from '@tanstack/router-core'\nimport type { Signal } from '@angular/core'\n\nexport interface MatchBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n> {\n  select?: (\n    match: MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>,\n  ) => TSelected\n  shouldThrow?: TThrow\n  injector?: Injector\n}\n\nexport type MatchRoute<TObservable extends boolean, out TFrom> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: MatchBaseOptions<TRouter, TFrom, true, true, TSelected>,\n) => TObservable extends true\n  ? Observable<MatchResult<TRouter, TFrom, true, TSelected>>\n  : Signal<MatchResult<TRouter, TFrom, true, TSelected>>\n\nexport type MatchOptions<\n  TRouter extends AnyRouter,\n  TFrom extends string | undefined,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\n  MatchBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>\n\nexport type MatchResult<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TSelected,\n> = unknown extends TSelected\n  ? TStrict extends true\n    ? MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>\n    : MakeRouteMatchUnion<TRouter>\n  : TSelected\n\nexport function match$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: MatchOptions<\n  TRouter,\n  TFrom,\n  TStrict,\n  ThrowConstraint<TStrict, TThrow>,\n  TSelected\n>): Observable<\n  ThrowOrOptional<MatchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>\n> {\n  !injector && assertInInjectionContext(match$)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    const closestMatchId = inject(MATCH_ID, { optional: true })\n    const nearestMatchId = computed(() => {\n      if (opts.from) return null\n      return closestMatchId\n    })\n\n    return combineLatest([\n      routerState$({ select: (s) => s.matches, injector }),\n      toObservable(nearestMatchId),\n    ]).pipe(\n      map(([matches, matchId]) => {\n        const match = matches.find((d) => {\n          return opts.from ? opts.from === d.routeId : d.id === matchId\n        })\n        invariant(\n          !((opts.shouldThrow ?? true) && !match),\n          `Could not find ${opts.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'}`,\n        )\n        if (match === undefined) {\n          return undefined\n        }\n\n        return opts.select ? opts.select(match) : match\n      }),\n    ) as any\n  })\n}\n\nexport function match<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: MatchOptions<\n  TRouter,\n  TFrom,\n  TStrict,\n  ThrowConstraint<TStrict, TThrow>,\n  TSelected\n>): Signal<\n  ThrowOrOptional<MatchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>\n> {\n  !injector && assertInInjectionContext(match)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(match$({ injector, ...opts } as unknown as any), {\n      injector,\n    })\n  }) as any\n}\n", "import {\n  Injector,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toSignal } from '@angular/core/rxjs-interop'\nimport { match$ } from './match'\n\nimport type { Signal } from '@angular/core'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  ResolveUseLoaderData,\n  StrictOrFrom,\n  UseLoaderDataResult,\n} from '@tanstack/router-core'\n\nimport type { Observable } from 'rxjs'\n\nexport interface LoaderDataBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TSelected,\n> {\n  select?: (match: ResolveUseLoaderData<TRouter, TFrom, TStrict>) => TSelected\n  injector?: Injector\n}\n\nexport type LoaderDataOptions<\n  TRouter extends AnyRouter,\n  TFrom extends string | undefined,\n  TStrict extends boolean,\n  TSelected,\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\n  LoaderDataBaseOptions<TRouter, TFrom, TStrict, TSelected>\n\nexport type LoaderDataRoute<TObservable extends boolean, out TId> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: LoaderDataBaseOptions<TRouter, TId, true, TSelected>,\n) => TObservable extends true\n  ? Observable<UseLoaderDataResult<TRouter, TId, true, TSelected>>\n  : Signal<UseLoaderDataResult<TRouter, TId, true, TSelected>>\n\nexport function loaderData$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: LoaderDataOptions<TRouter, TFrom, TStrict, TSelected>): Observable<\n  UseLoaderDataResult<TRouter, TFrom, TStrict, TSelected>\n> {\n  !injector && assertInInjectionContext(loaderData$)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return match$({\n      injector,\n      from: opts.from,\n      strict: opts.strict,\n      select: (s) => (opts.select ? opts.select(s.loaderData) : s.loaderData),\n    }) as any\n  })\n}\n\nexport function loaderData<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: LoaderDataOptions<TRouter, TFrom, TStrict, TSelected>): Signal<\n  UseLoaderDataResult<TRouter, TFrom, TStrict, TSelected>\n> {\n  !injector && assertInInjectionContext(loaderData)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(loaderData$({ injector, ...opts } as unknown as any), {\n      injector,\n    })\n  }) as any\n}\n", "import {\n  Injector,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toSignal } from '@angular/core/rxjs-interop'\nimport { match$ } from './match'\n\nimport type { Signal } from '@angular/core'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  ResolveUseLoaderDeps,\n  StrictOrFrom,\n  UseLoaderDepsResult,\n} from '@tanstack/router-core'\nimport type { Observable } from 'rxjs'\n\nexport interface LoaderDepsBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TSelected,\n> {\n  select?: (deps: ResolveUseLoaderDeps<TRouter, TFrom>) => TSelected\n  injector?: Injector\n}\n\nexport type LoaderDepsOptions<\n  TRouter extends AnyRouter,\n  TFrom extends string | undefined,\n  TSelected,\n> = StrictOrFrom<TRouter, TFrom> &\n  LoaderDepsBaseOptions<TRouter, TFrom, TSelected>\n\nexport type LoaderDepsRoute<TObservable extends boolean, out TId> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: LoaderDepsBaseOptions<TRouter, TId, TSelected>,\n) => TObservable extends true\n  ? Observable<UseLoaderDepsResult<TRouter, TId, TSelected>>\n  : Signal<UseLoaderDepsResult<TRouter, TId, TSelected>>\n\nexport function loaderDeps$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: LoaderDepsOptions<TRouter, TFrom, TSelected>): Observable<\n  UseLoaderDepsResult<TRouter, TFrom, TSelected>\n> {\n  !injector && assertInInjectionContext(loaderDeps$)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    const { select, ...rest } = opts\n    return match$({\n      ...rest,\n      select: (s) => {\n        return select ? select(s.loaderDeps) : s.loaderDeps\n      },\n    }) as Observable<UseLoaderDepsResult<TRouter, TFrom, TSelected>>\n  })\n}\n\nexport function loaderDeps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: LoaderDepsOptions<TRouter, TFrom, TSelected>): Signal<\n  UseLoaderDepsResult<TRouter, TFrom, TSelected>\n> {\n  !injector && assertInInjectionContext(loaderDeps)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(loaderDeps$({ injector, ...opts }), { injector })\n  }) as any\n}\n", "import {\n  Injector,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toSignal } from '@angular/core/rxjs-interop'\nimport { match$ } from './match'\n\nimport type { Signal } from '@angular/core'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  ResolveUseParams,\n  StrictOrFrom,\n  ThrowConstraint,\n  ThrowOrOptional,\n  UseParamsResult,\n} from '@tanstack/router-core'\nimport type { Observable } from 'rxjs'\n\nexport interface ParamsBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n> {\n  select?: (params: ResolveUseParams<TRouter, TFrom, TStrict>) => TSelected\n  shouldThrow?: TThrow\n  injector?: Injector\n}\n\nexport type ParamsOptions<\n  TRouter extends AnyRouter,\n  TFrom extends string | undefined,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\n  ParamsBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>\n\nexport type ParamsRoute<TObservable extends boolean, out TFrom> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: ParamsBaseOptions<\n    TRouter,\n    TFrom,\n    /* TStrict */ true,\n    /* TThrow */ true,\n    TSelected\n  >,\n) => TObservable extends true\n  ? Observable<UseParamsResult<TRouter, TFrom, true, TSelected>>\n  : Signal<UseParamsResult<TRouter, TFrom, true, TSelected>>\n\nexport function params$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: ParamsOptions<\n  TRouter,\n  TFrom,\n  TStrict,\n  ThrowConstraint<TStrict, TThrow>,\n  TSelected\n>): Observable<\n  ThrowOrOptional<UseParamsResult<TRouter, TFrom, TStrict, TSelected>, TThrow>\n> {\n  !injector && assertInInjectionContext(params)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return match$({\n      from: opts.from!,\n      strict: opts.strict,\n      shouldThrow: opts.shouldThrow,\n      select: (match) => {\n        return opts.select ? opts.select(match.params) : match.params\n      },\n    }) as any\n  })\n}\n\nexport function params<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: ParamsOptions<\n  TRouter,\n  TFrom,\n  TStrict,\n  ThrowConstraint<TStrict, TThrow>,\n  TSelected\n>): Signal<\n  ThrowOrOptional<UseParamsResult<TRouter, TFrom, TStrict, TSelected>, TThrow>\n> {\n  !injector && assertInInjectionContext(params)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(params$({ injector, ...opts } as unknown as any)) as any\n  })\n}\n", "import {\n  Injector,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toSignal } from '@angular/core/rxjs-interop'\nimport { match$ } from './match'\n\nimport type { Signal } from '@angular/core'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  UseRouteContextBaseOptions,\n  UseRouteContextOptions,\n  UseRouteContextResult,\n} from '@tanstack/router-core'\nimport type { Observable } from 'rxjs'\n\nexport type RouteContextRoute<TObservable extends boolean, out TFrom> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: UseRouteContextBaseOptions<TRouter, TFrom, true, TSelected> & {\n    injector?: Injector\n  },\n) => TObservable extends true\n  ? Observable<UseRouteContextResult<TRouter, TFrom, true, TSelected>>\n  : Signal<UseRouteContextResult<TRouter, TFrom, true, TSelected>>\n\nexport function routeContext$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: UseRouteContextOptions<TRouter, TFrom, TStrict, TSelected> & {\n  injector?: Injector\n}): Observable<UseRouteContextResult<TRouter, TFrom, TStrict, TSelected>> {\n  !injector && assertInInjectionContext(routeContext)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return match$({\n      ...(opts as any),\n      select: (match) => {\n        return opts.select ? opts.select(match.context) : match.context\n      },\n    }) as any\n  })\n}\n\nexport function routeContext<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: UseRouteContextOptions<TRouter, TFrom, TStrict, TSelected> & {\n  injector?: Injector\n}): Signal<UseRouteContextResult<TRouter, TFrom, TStrict, TSelected>> {\n  !injector && assertInInjectionContext(routeContext)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(\n      routeContext$({ injector, ...opts } as unknown as any),\n    ) as any\n  })\n}\n", "import {\n  Injector,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toSignal } from '@angular/core/rxjs-interop'\nimport { match$ } from './match'\n\nimport type { Signal } from '@angular/core'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  ResolveUseSearch,\n  StrictOrFrom,\n  ThrowConstraint,\n  ThrowOrOptional,\n  UseSearchResult,\n} from '@tanstack/router-core'\nimport type { Observable } from 'rxjs'\n\nexport interface SearchBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n> {\n  select?: (state: ResolveUseSearch<TRouter, TFrom, TStrict>) => TSelected\n  shouldThrow?: TThrow\n  injector?: Injector\n}\n\nexport type SearchOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\n  SearchBaseOptions<TRouter, TFrom, TStrict, TThrow, TSelected>\n\nexport type SearchRoute<TObservable extends boolean, out TFrom> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>(\n  opts?: SearchBaseOptions<\n    TRouter,\n    TFrom,\n    /* TStrict */ true,\n    /* TThrow */ true,\n    TSelected\n  >,\n) => TObservable extends true\n  ? Observable<UseSearchResult<TRouter, TFrom, true, TSelected>>\n  : Signal<UseSearchResult<TRouter, TFrom, true, TSelected>>\n\nexport function search$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: SearchOptions<\n  TRouter,\n  TFrom,\n  TStrict,\n  ThrowConstraint<TStrict, TThrow>,\n  TSelected\n>): Observable<\n  ThrowOrOptional<UseSearchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>\n> {\n  !injector && assertInInjectionContext(search)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return match$({\n      from: opts.from!,\n      strict: opts.strict,\n      shouldThrow: opts.shouldThrow,\n      select: (match) => {\n        return opts.select ? opts.select(match.search) : match.search\n      },\n    }) as any\n  })\n}\n\nexport function search<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: SearchOptions<\n  TRouter,\n  TFrom,\n  TStrict,\n  ThrowConstraint<TStrict, TThrow>,\n  TSelected\n>): Signal<\n  ThrowOrOptional<UseSearchResult<TRouter, TFrom, TStrict, TSelected>, TThrow>\n> {\n  !injector && assertInInjectionContext(search)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(search$({ injector, ...opts } as unknown as any)) as any\n  })\n}\n", "import { InjectionToken, runInInjectionContext } from '@angular/core'\nimport { BaseRootRoute, BaseRoute, BaseRouteApi } from '@tanstack/router-core'\nimport { loaderData, loaderData$ } from './loader-data'\nimport { loaderDeps, loaderDeps$ } from './loader-deps'\nimport { match, match$ } from './match'\nimport { params, params$ } from './params'\nimport { routeContext, routeContext$ } from './route-context'\nimport { search, search$ } from './search'\n\nimport type { Provider, Type } from '@angular/core'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouter,\n  ConstrainLiteral,\n  ErrorComponentProps,\n  NotFoundRouteProps,\n  RegisteredRouter,\n  ResolveFullPath,\n  ResolveId,\n  ResolveParams,\n  RootRouteId,\n  RootRouteOptions,\n  RouteConstraints,\n  RouteIds,\n  RouteOptions,\n} from '@tanstack/router-core'\nimport type { LoaderDataRoute } from './loader-data'\nimport type { LoaderDepsRoute } from './loader-deps'\nimport type { MatchRoute } from './match'\nimport type { ParamsRoute } from './params'\nimport type { RouteContextRoute } from './route-context'\nimport type { SearchRoute } from './search'\n\ndeclare module '@tanstack/router-core' {\n  export interface UpdatableRouteOptionsExtensions {\n    component?: () => RouteComponent\n    errorComponent?: false | null | (() => RouteComponent)\n    notFoundComponent?: () => RouteComponent\n    pendingComponent?: () => RouteComponent\n    providers?: Array<Provider>\n  }\n\n  export interface RouteExtensions<\n    TId extends string,\n    TFullPath extends string,\n  > {\n    match$: MatchRoute<true, TId>\n    match: MatchRoute<false, TId>\n    routeContext$: RouteContextRoute<true, TId>\n    routeContext: RouteContextRoute<false, TId>\n    search$: SearchRoute<true, TId>\n    search: SearchRoute<false, TId>\n    params$: ParamsRoute<true, TId>\n    params: ParamsRoute<false, TId>\n    loaderDeps$: LoaderDepsRoute<true, TId>\n    loaderDeps: LoaderDepsRoute<false, TId>\n    loaderData$: LoaderDataRoute<true, TId>\n    loaderData: LoaderDataRoute<false, TId>\n  }\n}\n\nexport const ERROR_COMPONENT_CONTEXT = new InjectionToken<ErrorComponentProps>(\n  'ERROR_COMPONENT_CONTEXT',\n)\nexport const NOT_FOUND_COMPONENT_CONTEXT =\n  new InjectionToken<NotFoundRouteProps>('NOT_FOUND_COMPONENT_CONTEXT')\n\nexport type RouteComponent<TComponent extends object = object> =\n  Type<TComponent>\n\nexport function routeApi<\n  const TId,\n  TRouter extends AnyRouter = RegisteredRouter,\n>(id: ConstrainLiteral<TId, RouteIds<TRouter['routeTree']>>) {\n  return new RouteApi<TId, TRouter>({ id })\n}\n\nexport class RouteApi<\n  TId,\n  TRouter extends AnyRouter = RegisteredRouter,\n> extends BaseRouteApi<TId, TRouter> {\n  /**\n   * @deprecated Use the `getRouteApi` function instead.\n   */\n  constructor({ id }: { id: TId }) {\n    super({ id })\n  }\n\n  match$: MatchRoute<true, TId> = (opts) =>\n    match$({ ...opts, from: this.id } as any) as any\n  match: MatchRoute<false, TId> = (opts) =>\n    match({ ...opts, from: this.id } as any) as any\n\n  routeContext$: RouteContextRoute<true, TId> = (opts) =>\n    routeContext$({ ...opts, from: this.id } as unknown as any)\n  routeContext: RouteContextRoute<false, TId> = (opts) =>\n    routeContext({ ...opts, from: this.id } as unknown as any)\n\n  search$: SearchRoute<true, TId> = (opts) =>\n    search$({ ...opts, from: this.id } as any) as any\n  search: SearchRoute<false, TId> = (opts) =>\n    search({ ...opts, from: this.id } as any) as any\n\n  params$: ParamsRoute<true, TId> = (opts) =>\n    params$({ ...opts, from: this.id } as any) as any\n  params: ParamsRoute<false, TId> = (opts) =>\n    params({ ...opts, from: this.id } as any) as any\n\n  loaderDeps$: LoaderDepsRoute<true, TId> = (opts) =>\n    loaderDeps$({ ...opts, from: this.id } as any)\n  loaderDeps: LoaderDepsRoute<false, TId> = (opts) =>\n    loaderDeps({ ...opts, from: this.id, strict: false } as any)\n\n  loaderData$: LoaderDataRoute<true, TId> = (opts) =>\n    loaderData$({ ...opts, from: this.id } as any)\n  loaderData: LoaderDataRoute<false, TId> = (opts) =>\n    loaderData({ ...opts, from: this.id, strict: false } as any)\n}\n\nexport class Route<\n  in out TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  in out TPath extends RouteConstraints['TPath'] = '/',\n  in out TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  in out TCustomId extends RouteConstraints['TCustomId'] = string,\n  in out TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  in out TSearchValidator = undefined,\n  in out TParams = ResolveParams<TPath>,\n  in out TRouterContext = AnyContext,\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n  in out TLoaderDeps extends Record<string, any> = {},\n  in out TLoaderFn = undefined,\n  in out TChildren = unknown,\n  in out TFileRouteTypes = unknown,\n> extends BaseRoute<\n  TParentRoute,\n  TPath,\n  TFullPath,\n  TCustomId,\n  TId,\n  TSearchValidator,\n  TParams,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TChildren,\n  TFileRouteTypes\n> {\n  /**\n   * @deprecated Use the `createRoute` function instead.\n   */\n  constructor(\n    options?: RouteOptions<\n      TParentRoute,\n      TId,\n      TCustomId,\n      TFullPath,\n      TPath,\n      TSearchValidator,\n      TParams,\n      TLoaderDeps,\n      TLoaderFn,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    >,\n  ) {\n    super(options)\n  }\n\n  match$: MatchRoute<true, TId> = (opts) =>\n    match$({ ...opts, from: this.id } as any) as any\n  match: MatchRoute<false, TId> = (opts) =>\n    match({ ...opts, from: this.id } as any) as any\n\n  routeContext$: RouteContextRoute<true, TId> = (opts) =>\n    routeContext$({ ...opts, from: this.id } as unknown as any)\n  routeContext: RouteContextRoute<false, TId> = (opts) =>\n    routeContext({ ...opts, from: this.id } as unknown as any)\n\n  search$: SearchRoute<true, TId> = (opts) =>\n    search$({ ...opts, from: this.id } as any) as any\n  search: SearchRoute<false, TId> = (opts) =>\n    search({ ...opts, from: this.id } as any) as any\n\n  params$: ParamsRoute<true, TId> = (opts) =>\n    params$({ ...opts, from: this.id } as any) as any\n  params: ParamsRoute<false, TId> = (opts) =>\n    params({ ...opts, from: this.id } as any) as any\n\n  loaderDeps$: LoaderDepsRoute<true, TId> = (opts) =>\n    loaderDeps$({ ...opts, from: this.id } as any)\n  loaderDeps: LoaderDepsRoute<false, TId> = (opts) =>\n    loaderDeps({ ...opts, from: this.id } as any)\n\n  loaderData$: LoaderDataRoute<true, TId> = (opts) =>\n    loaderData$({ ...opts, from: this.id } as any)\n  loaderData: LoaderDataRoute<false, TId> = (opts) =>\n    loaderData({ ...opts, from: this.id } as any)\n}\n\nexport function createRoute<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchValidator = undefined,\n  TParams = ResolveParams<TPath>,\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TChildren = unknown,\n>(\n  options: RouteOptions<\n    TParentRoute,\n    TId,\n    TCustomId,\n    TFullPath,\n    TPath,\n    TSearchValidator,\n    TParams,\n    TLoaderDeps,\n    TLoaderFn,\n    AnyContext,\n    TRouteContextFn,\n    TBeforeLoadFn\n  >,\n): Route<\n  TParentRoute,\n  TPath,\n  TFullPath,\n  TCustomId,\n  TId,\n  TSearchValidator,\n  TParams,\n  AnyContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TChildren,\n  unknown\n> {\n  if (options.loader) {\n    options.loader = runFnInInjectionContext(options.loader)\n  }\n\n  if (options.shouldReload && typeof options.shouldReload === 'function') {\n    options.shouldReload = runFnInInjectionContext(options.shouldReload)\n  }\n\n  if (options.beforeLoad) {\n    options.beforeLoad = runFnInInjectionContext(options.beforeLoad)\n  }\n\n  return new Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchValidator,\n    TParams,\n    AnyContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    unknown\n  >(options)\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any, any, any, any, any>\n\nexport function createRootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TRouteContextFn = AnyContext,\n    TBeforeLoadFn = AnyContext,\n    TSearchValidator = undefined,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderFn = undefined,\n  >(\n    options?: RootRouteOptions<\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn\n    >,\n  ) => {\n    return createRootRoute<\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn\n    >(options as any)\n  }\n}\n\nexport class RootRoute<\n  in out TSearchValidator = undefined,\n  in out TRouterContext = {},\n  in out TRouteContextFn = AnyContext,\n  in out TBeforeLoadFn = AnyContext,\n  in out TLoaderDeps extends Record<string, any> = {},\n  in out TLoaderFn = undefined,\n  in out TChildren = unknown,\n  in out TFileRouteTypes = unknown,\n> extends BaseRootRoute<\n  TSearchValidator,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TChildren,\n  TFileRouteTypes\n> {\n  /**\n   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n   */\n  constructor(\n    options?: RootRouteOptions<\n      TSearchValidator,\n      TRouterContext,\n      TRouteContextFn,\n      TBeforeLoadFn,\n      TLoaderDeps,\n      TLoaderFn\n    >,\n  ) {\n    super(options)\n  }\n\n  match$: MatchRoute<true, RootRouteId> = (opts) =>\n    match$({ ...opts, from: this.id } as any) as any\n  match: MatchRoute<false, RootRouteId> = (opts) =>\n    match({ ...opts, from: this.id } as any) as any\n\n  routeContext$: RouteContextRoute<true, RootRouteId> = (opts) =>\n    routeContext$({ ...opts, from: this.id } as unknown as any)\n  routeContext: RouteContextRoute<false, RootRouteId> = (opts) =>\n    routeContext({ ...opts, from: this.id } as unknown as any)\n\n  search$: SearchRoute<true, RootRouteId> = (opts) =>\n    search$({ ...opts, from: this.id } as any) as any\n  search: SearchRoute<false, RootRouteId> = (opts) =>\n    search({ ...opts, from: this.id } as any) as any\n\n  params$: ParamsRoute<true, RootRouteId> = (opts) =>\n    params$({ ...opts, from: this.id } as any) as any\n  params: ParamsRoute<false, RootRouteId> = (opts) =>\n    params({ ...opts, from: this.id } as any) as any\n\n  loaderDeps$: LoaderDepsRoute<true, RootRouteId> = (opts) =>\n    loaderDeps$({ ...opts, from: this.id } as any)\n  loaderDeps: LoaderDepsRoute<false, RootRouteId> = (opts) =>\n    loaderDeps({ ...opts, from: this.id } as any)\n\n  loaderData$: LoaderDataRoute<true, RootRouteId> = (opts) =>\n    loaderData$({ ...opts, from: this.id } as any)\n  loaderData: LoaderDataRoute<false, RootRouteId> = (opts) =>\n    loaderData({ ...opts, from: this.id } as any)\n}\n\nexport function createRootRoute<\n  TSearchValidator = undefined,\n  TRouterContext = {},\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n>(\n  options?: RootRouteOptions<\n    TSearchValidator,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn\n  >,\n): RootRoute<\n  TSearchValidator,\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  unknown,\n  unknown\n> {\n  return new RootRoute<\n    TSearchValidator,\n    TRouterContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn\n  >(options)\n}\n\nexport class NotFoundRoute<\n  TParentRoute extends AnyRootRoute,\n  TRouterContext = AnyContext,\n  TRouteContextFn = AnyContext,\n  TBeforeLoadFn = AnyContext,\n  TSearchValidator = undefined,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderFn = undefined,\n  TChildren = unknown,\n> extends Route<\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchValidator,\n  {},\n  TRouterContext,\n  TRouteContextFn,\n  TBeforeLoadFn,\n  TLoaderDeps,\n  TLoaderFn,\n  TChildren\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        string,\n        string,\n        TSearchValidator,\n        {},\n        TLoaderDeps,\n        TLoaderFn,\n        TRouterContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n      | 'path'\n      | 'id'\n      | 'params'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n\nfunction runFnInInjectionContext<TFn extends (...args: Array<any>) => any>(\n  fn: TFn,\n) {\n  const originalFn = fn\n  return (...args: Parameters<TFn>) => {\n    const { context, location, route } = args[0]\n    const routeInjector = context.getRouteInjector(route?.id || location.href)\n    return runInInjectionContext(routeInjector, originalFn.bind(null, ...args))\n  }\n}\n", "import {\n  ChangeDetectionStrategy,\n  Component,\n  inject,\n  signal,\n} from '@angular/core'\nimport { ERROR_COMPONENT_CONTEXT } from './route'\n\n@Component({\n  selector: 'default-error,DefaultError',\n  template: `\n    <div style=\"display: flex; align-items: center; gap: 0.5rem\">\n      <strong style=\"font-size: 1rem\">Something went wrong!</strong>\n      <button\n        style=\"appearance: none; font-size: 0.6em; border: 1px solid currentColor; padding: 0.1rem 0.2rem; font-weight: bold; border-radius: 0.25rem\"\n        (click)=\"show.set(!show())\"\n      >\n        {{ show() ? 'Hide Error' : 'Show Error' }}\n      </button>\n    </div>\n    <div style=\"height: 0.25rem\"></div>\n    @if (show()) {\n      <div>\n        <pre\n          style=\"font-size: 0.7em; border: 1px solid red; border-radius: 0.25rem; padding: 0.3rem; color: red; overflow: auto\"\n        >\n          @if (context.error.message; as message) {\n            <code>{{ message }}</code>\n          }\n        </pre>\n      </div>\n    }\n  `,\n  styles: `\n    :host {\n      display: block;\n      padding: 0.5rem;\n      max-width: 100%;\n    }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class DefaultError {\n  protected context = inject(ERROR_COMPONENT_CONTEXT)\n  protected show = signal(false)\n}\n", "import { DOCUMENT } from '@angular/common'\nimport {\n  ChangeDetectorRef,\n  DestroyRef,\n  Directive,\n  afterNextRender,\n  inject,\n  untracked,\n} from '@angular/core'\nimport { getLocationChangeInfo, trimPathRight } from '@tanstack/router-core'\nimport {\n  BehaviorSubject,\n  Subscription,\n  combineLatest,\n  distinctUntilChanged,\n  map,\n  pairwise,\n  startWith,\n  tap,\n} from 'rxjs'\nimport { injectRouter } from './router'\nimport { routerState$ } from './router-state'\n\nimport type { OnInit } from '@angular/core'\n\n@Directive()\nexport class Transitioner implements OnInit {\n  private router = injectRouter()\n  private destroyRef = inject(DestroyRef)\n  private document = inject(DOCUMENT)\n  private cdr = inject(ChangeDetectorRef)\n\n  private matches$ = routerState$({ select: (s) => s.matches })\n  private hasPendingMatches$ = this.matches$.pipe(\n    map((matches) => matches.some((d) => d.status === 'pending')),\n    distinctUntilChanged(() => false),\n  )\n  private isLoading$ = routerState$({\n    select: (s) => s.isLoading,\n    equal: () => false,\n  })\n  private previousIsLoading$ = this.isLoading$.pipe(\n    startWith(undefined),\n    pairwise(),\n    map(([prev, curr]) => prev ?? !!curr),\n  )\n\n  private isTransitioning$ = new BehaviorSubject(false)\n  private isAnyPending$ = combineLatest([\n    this.isLoading$,\n    this.isTransitioning$,\n    this.hasPendingMatches$,\n  ]).pipe(\n    map(\n      ([isLoading, isTransitioning, hasPendingMatches]) =>\n        isLoading || isTransitioning || hasPendingMatches,\n    ),\n    distinctUntilChanged(() => false),\n  )\n  private previousIsAnyPending$ = this.isAnyPending$.pipe(\n    startWith(undefined),\n    pairwise(),\n    map(([prev, curr]) => prev ?? !!curr),\n  )\n\n  private isPagePending$ = combineLatest([\n    this.isLoading$,\n    this.hasPendingMatches$,\n  ]).pipe(\n    map(([isLoading, hasPendingMatches]) => isLoading || hasPendingMatches),\n    distinctUntilChanged(() => false),\n  )\n  private previousIsPagePending$ = this.isPagePending$.pipe(\n    startWith(undefined),\n    pairwise(),\n    map(([prev, curr]) => prev ?? !!curr),\n  )\n\n  private mountLoadForRouter = { router: this.router, mounted: false }\n\n  private load$ = combineLatest([\n    this.previousIsLoading$,\n    this.isLoading$,\n  ]).pipe(\n    tap(([previousIsLoading, isLoading]) => {\n      if (previousIsLoading && !isLoading) {\n        this.router.emit({\n          type: 'onLoad',\n          ...getLocationChangeInfo(this.router.state),\n        })\n        this.router.__store.setState((s) => ({ ...s, status: 'idle' }))\n      }\n    }),\n  )\n  private pagePending$ = combineLatest([\n    this.previousIsPagePending$,\n    this.isPagePending$,\n  ]).pipe(\n    tap(([previousIsPagePending, isPagePending]) => {\n      // emit onBeforeRouteMount\n      if (previousIsPagePending && !isPagePending) {\n        this.router.emit({\n          type: 'onBeforeRouteMount',\n          ...getLocationChangeInfo(this.router.state),\n        })\n      }\n    }),\n  )\n  private pending$ = combineLatest([\n    this.previousIsAnyPending$,\n    this.isAnyPending$,\n  ]).pipe(\n    tap(([previousIsAnyPending, isAnyPending]) => {\n      // The router was pending and now it's not\n      if (previousIsAnyPending && !isAnyPending) {\n        this.router.emit({\n          type: 'onResolved',\n          ...getLocationChangeInfo(this.router.state),\n        })\n\n        this.router.__store.setState((s) => ({\n          ...s,\n          status: 'idle',\n          resolvedLocation: s.location,\n        }))\n        if (\n          typeof this.document !== 'undefined' &&\n          'querySelector' in this.document\n        ) {\n          const hashScrollIntoViewOptions =\n            this.router.state.location.state.__hashScrollIntoViewOptions ?? true\n\n          if (\n            hashScrollIntoViewOptions &&\n            this.router.state.location.hash !== ''\n          ) {\n            const el = this.document.getElementById(\n              this.router.state.location.hash,\n            )\n            if (el) el.scrollIntoView(hashScrollIntoViewOptions)\n          }\n        }\n      }\n    }),\n  )\n\n  constructor() {\n    if (!this.router.isServer) {\n      this.router.startTransition = (fn) => {\n        this.isTransitioning$.next(true)\n        fn()\n        this.isTransitioning$.next(false)\n        this.cdr.detectChanges()\n      }\n    }\n\n    const subscription = new Subscription()\n\n    // Try to load the initial location\n    afterNextRender(() => {\n      untracked(() => {\n        const window = this.document.defaultView\n        if (\n          (typeof window !== 'undefined' && this.router.clientSsr) ||\n          (this.mountLoadForRouter.router === this.router &&\n            this.mountLoadForRouter.mounted)\n        ) {\n          return\n        }\n        this.mountLoadForRouter = { router: this.router, mounted: true }\n        const tryLoad = async () => {\n          try {\n            await this.router.load()\n            this.router.__store.setState((s) => ({ ...s, status: 'idle' }))\n          } catch (err) {\n            console.error(err)\n          }\n        }\n        void tryLoad()\n      })\n\n      subscription.add(this.load$.subscribe())\n      subscription.add(this.pagePending$.subscribe())\n      subscription.add(this.pending$.subscribe())\n    })\n\n    this.destroyRef.onDestroy(() => subscription.unsubscribe())\n  }\n\n  ngOnInit() {\n    // Subscribe to location changes\n    // and try to load the new location\n    const unsub = this.router.history.subscribe(() => this.router.load())\n\n    const nextLocation = this.router.buildLocation({\n      to: this.router.latestLocation.pathname,\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n      _includeValidateSearch: true,\n    })\n\n    if (\n      trimPathRight(this.router.latestLocation.href) !==\n      trimPathRight(nextLocation.href)\n    ) {\n      void this.router.commitLocation({ ...nextLocation, replace: true })\n    }\n\n    this.destroyRef.onDestroy(() => unsub())\n  }\n}\n", "import {\n  DestroyRef,\n  Directive,\n  Injector,\n  ViewContainerRef,\n  afterNextRender,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toSignal } from '@angular/core/rxjs-interop'\nimport { combineLatest, map, of, switchMap } from 'rxjs'\nimport { DefaultError } from './default-error'\nimport { distinctUntilRefChanged } from './distinct-until-ref-changed'\nimport { MATCH_ID, RouteMatch } from './outlet'\nimport { ERROR_COMPONENT_CONTEXT } from './route'\nimport { injectRouter } from './router'\nimport { routerState$ } from './router-state'\nimport { Transitioner } from './transitioner'\n\nimport type { Observable, Subscription } from 'rxjs'\nimport type {\n  AnyRouter,\n  MakeRouteMatchUnion,\n  RegisteredRouter,\n  RouterState,\n} from '@tanstack/router-core'\nimport type { ComponentRef, Signal } from '@angular/core'\n\n@Directive({ hostDirectives: [Transitioner] })\nexport class Matches {\n  private router = injectRouter()\n  private injector = inject(Injector)\n  private vcr = inject(ViewContainerRef)\n\n  private defaultPendingComponent =\n    this.router.options.defaultPendingComponent?.()\n\n  private resetKey$ = routerState$({ select: (s) => s.loadedAt.toString() })\n  private rootMatchId$ = routerState$({ select: (s) => s.matches[0]?.id })\n\n  private matchLoad$ = this.rootMatchId$.pipe(\n    switchMap((rootMatchId) => {\n      if (!rootMatchId) return of({ pending: false })\n      const loadPromise = this.router.getMatch(rootMatchId)?.loadPromise\n      if (!loadPromise) return of({ pending: false })\n      return of({ pending: true }).pipe(\n        switchMap(() => loadPromise.then(() => ({ pending: false }))),\n      )\n    }),\n  )\n\n  private cmpRef?: ComponentRef<any>\n\n  private run$ = this.matchLoad$.pipe(\n    switchMap(({ pending }) => {\n      if (pending) {\n        if (this.defaultPendingComponent) {\n          return of({\n            component: this.defaultPendingComponent,\n            clearView: true,\n            matchId: null,\n          } as const)\n        }\n        return of(null)\n      }\n\n      return combineLatest([this.rootMatchId$, this.resetKey$]).pipe(\n        map(([matchId]) => {\n          if (!matchId) return null\n          if (this.cmpRef) return { clearView: false } as const\n          return {\n            component: RouteMatch,\n            matchId,\n            clearView: true,\n          } as const\n        }),\n      )\n    }),\n  )\n\n  constructor() {\n    let subscription: Subscription\n    afterNextRender(() => {\n      subscription = this.run$.subscribe({\n        next: (runData) => {\n          if (!runData) return\n          if (!runData.clearView) {\n            this.cmpRef?.changeDetectorRef.markForCheck()\n            return\n          }\n          const { component, matchId } = runData\n          this.vcr.clear()\n          this.cmpRef = this.vcr.createComponent(component)\n          if (matchId) {\n            this.cmpRef.setInput('matchId', matchId)\n          }\n          this.cmpRef.changeDetectorRef.markForCheck()\n        },\n        error: (error) => {\n          console.error(error)\n          const injector = Injector.create({\n            providers: [\n              {\n                provide: ERROR_COMPONENT_CONTEXT,\n                useValue: {\n                  error: error,\n                  info: { componentStack: '' },\n                  reset: () => void this.router.invalidate(),\n                },\n              },\n            ],\n            parent: this.injector,\n          })\n          this.vcr.clear()\n          const ref = this.vcr.createComponent(DefaultError, { injector })\n          ref.changeDetectorRef.markForCheck()\n          this.cmpRef = undefined\n        },\n      })\n    })\n\n    inject(DestroyRef).onDestroy(() => {\n      subscription.unsubscribe()\n      this.vcr.clear()\n      this.cmpRef = undefined\n    })\n  }\n}\n\nexport interface MatchesBaseOptions<TRouter extends AnyRouter, TSelected> {\n  select?: (matches: Array<MakeRouteMatchUnion<TRouter>>) => TSelected\n  injector?: Injector\n}\n\nexport type MatchesResult<\n  TRouter extends AnyRouter,\n  TSelected,\n> = unknown extends TSelected ? Array<MakeRouteMatchUnion<TRouter>> : TSelected\n\nexport function matches$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: MatchesBaseOptions<TRouter, TSelected> = {}): Observable<\n  MatchesResult<TRouter, TSelected>\n> {\n  !injector && assertInInjectionContext(matches$)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return routerState$({\n      injector,\n      select: (state: RouterState<TRouter['routeTree']>) => {\n        const matches = state.matches\n        return opts.select\n          ? opts.select(matches as Array<MakeRouteMatchUnion<TRouter>>)\n          : matches\n      },\n    }) as Observable<MatchesResult<TRouter, TSelected>>\n  })\n}\n\nexport function matches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>({ injector, ...opts }: MatchesBaseOptions<TRouter, TSelected> = {}): Signal<\n  MatchesResult<TRouter, TSelected>\n> {\n  !injector && assertInInjectionContext(matches)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(matches$({ injector, ...opts })) as Signal<\n      MatchesResult<TRouter, TSelected>\n    >\n  })\n}\n\nexport function parentMatches$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: MatchesBaseOptions<TRouter, TSelected> = {}): Observable<\n  MatchesResult<TRouter, TSelected>\n> {\n  !injector && assertInInjectionContext(parentMatches$)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    const closestMatch = inject(MATCH_ID)\n    return routerState$({ injector, select: (s) => s.matches }).pipe(\n      map((matches) => {\n        const sliced = matches.slice(\n          0,\n          matches.findIndex((d) => d.id === closestMatch),\n        )\n        return opts.select\n          ? opts.select(sliced as Array<MakeRouteMatchUnion<TRouter>>)\n          : sliced\n      }),\n      distinctUntilRefChanged() as any,\n    )\n  })\n}\n\nexport function parentMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>({ injector, ...opts }: MatchesBaseOptions<TRouter, TSelected> = {}): Signal<\n  MatchesResult<TRouter, TSelected>\n> {\n  !injector && assertInInjectionContext(parentMatches)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(parentMatches$({ injector, ...opts })) as Signal<\n      MatchesResult<TRouter, TSelected>\n    >\n  })\n}\nexport function childMatches$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>({\n  injector,\n  ...opts\n}: MatchesBaseOptions<TRouter, TSelected> = {}): Observable<\n  MatchesResult<TRouter, TSelected>\n> {\n  !injector && assertInInjectionContext(childMatches$)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    const closestMatch = inject(MATCH_ID)\n    return routerState$({ injector, select: (s) => s.matches }).pipe(\n      map((matches) => {\n        const sliced = matches.slice(\n          matches.findIndex((d) => d.id === closestMatch) + 1,\n        )\n        return opts.select\n          ? opts.select(sliced as Array<MakeRouteMatchUnion<TRouter>>)\n          : sliced\n      }),\n      distinctUntilRefChanged() as any,\n    )\n  })\n}\n\nexport function childMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>({ injector, ...opts }: MatchesBaseOptions<TRouter, TSelected> = {}): Signal<\n  MatchesResult<TRouter, TSelected>\n> {\n  !injector && assertInInjectionContext(childMatches)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(childMatches$({ injector, ...opts })) as Signal<\n      MatchesResult<TRouter, TSelected>\n    >\n  })\n}\n", "import {\n  Directive,\n  ElementRef,\n  afterRenderEffect,\n  computed,\n  inject,\n  input,\n  signal,\n  untracked,\n} from '@angular/core'\nimport { toObservable, toSignal } from '@angular/core/rxjs-interop'\nimport {\n  deepEqual,\n  exactPathTest,\n  preloadWarning,\n  removeTrailingSlash,\n} from '@tanstack/router-core'\nimport { combineLatest, map } from 'rxjs'\nimport { distinctUntilRefChanged } from './distinct-until-ref-changed'\nimport { matches$ } from './matches'\nimport { injectRouter } from './router'\nimport { routerState, routerState$ } from './router-state'\n\nimport type {\n  AnyRouter,\n  Constrain,\n  InferFrom,\n  InferMaskFrom,\n  InferMaskTo,\n  InferTo,\n  LinkOptions,\n  RegisteredRouter,\n} from '@tanstack/router-core'\n\n@Directive({\n  selector: 'a[link]',\n  exportAs: 'link',\n  host: {\n    '(click)': 'handleClick($event)',\n    '(focus)': 'handleFocus()',\n    '(touchstart)': 'handleClick($event)',\n    '(mouseenter)': 'handleMouseEnter($event)',\n    '(mouseleave)': 'handleMouseLeave()',\n    '[class]': 'activeClass()',\n    '[attr.data-active]': 'isActive()',\n    '[attr.data-type]': 'type()',\n    '[attr.data-transitioning]':\n      'transitioning() ? \"transitioning\" : undefined',\n    '[attr.href]': 'hostHref()',\n    '[attr.role]': 'disabled() ? \"link\" : undefined',\n    '[attr.aria-disabled]': 'disabled()',\n    '[attr.aria-current]': 'isActive() ? \"page\" : undefined',\n    '[attr.data-from]': 'from()',\n  },\n})\nexport class Link {\n  linkOptions = input.required({\n    alias: 'link',\n    transform: (\n      value:\n        | (Omit<LinkOptions, 'activeOptions'> & {\n            activeOptions?: LinkOptions['activeOptions'] & { class?: string }\n          })\n        | NonNullable<LinkOptions['to']>,\n    ) => {\n      return (typeof value === 'object' ? value : { to: value }) as Omit<\n        LinkOptions,\n        'activeOptions'\n      > & { activeOptions?: LinkOptions['activeOptions'] & { class?: string } }\n    },\n  })\n  linkActiveOptions = input(\n    { class: 'active' },\n    {\n      alias: 'linkActive',\n      transform: (\n        value: (LinkOptions['activeOptions'] & { class?: string }) | string,\n      ) => {\n        if (typeof value === 'string') return { class: value }\n\n        if (!value.class) value.class = 'active'\n        return value\n      },\n    },\n  )\n\n  private router = injectRouter()\n  hostElement = inject<ElementRef<HTMLAnchorElement>>(ElementRef)\n\n  private currentSearch = routerState({ select: (s) => s.location.searchStr })\n\n  protected disabled = computed(() => this.linkOptions()['disabled'])\n  private to = computed(() => this.linkOptions()['to'])\n  private userFrom = computed(() => this.linkOptions()['from'])\n  private userReloadDocument = computed(\n    () => this.linkOptions()['reloadDocument'],\n  )\n  private userPreload = computed(() => this.linkOptions()['preload'])\n  private userPreloadDelay = computed(() => this.linkOptions()['preloadDelay'])\n\n  private activeOptions = computed(\n    () => this.linkOptions().activeOptions || this.linkActiveOptions(),\n  )\n  private exactActiveOptions = computed(() => this.activeOptions().exact)\n  private includeHashActiveOptions = computed(\n    () => this.activeOptions().includeHash,\n  )\n  private includeSearchActiveOptions = computed(\n    () => this.activeOptions().includeSearch,\n  )\n\n  protected type = computed(() => {\n    const to = this.to()\n    try {\n      new URL(`${to}`)\n      return 'external'\n    } catch {\n      return 'internal'\n    }\n  })\n\n  // when `from` is not supplied, use the leaf route of the current matches as the `from` location\n  // so relative routing works as expected\n  protected from = toSignal(\n    combineLatest([\n      toObservable(this.userFrom),\n      matches$({ select: (matches) => matches[matches.length - 1]?.fullPath }),\n    ]).pipe(\n      map(([userFrom, from]) => userFrom ?? from),\n      distinctUntilRefChanged(),\n    ),\n  )\n\n  private navigateOptions = computed(() => {\n    return { ...this.linkOptions(), from: this.from() }\n  })\n\n  private next = computed(() => {\n    const [options] = [this.navigateOptions(), this.currentSearch()]\n    try {\n      return this.router.buildLocation(options as any)\n    } catch {\n      return null\n    }\n  })\n\n  private preload = computed(() => {\n    const userReloadDocument = this.userReloadDocument()\n    if (userReloadDocument) return false\n    const userPreload = this.userPreload()\n    if (userPreload) return userPreload\n    return this.router.options.defaultPreload\n  })\n\n  private preloadDelay = computed(() => {\n    const userPreloadDelay = this.userPreloadDelay()\n    if (userPreloadDelay) return userPreloadDelay\n    return this.router.options.defaultPreloadDelay\n  })\n\n  protected hostHref = computed(() => {\n    const [type, to] = [this.type(), this.to()]\n    if (type === 'external') return to\n\n    const disabled = this.disabled()\n    if (disabled) return undefined\n\n    const next = this.next()\n    if (!next) return undefined\n\n    return next.maskedLocation\n      ? this.router.history.createHref(next.maskedLocation.href)\n      : this.router.history.createHref(next.href)\n  })\n\n  transitioning = signal(false)\n\n  isActive = toSignal(\n    combineLatest([\n      toObservable(this.next),\n      toObservable(this.exactActiveOptions),\n      toObservable(this.includeSearchActiveOptions),\n      toObservable(this.includeHashActiveOptions),\n      routerState$({ select: (s) => s.location }),\n    ]).pipe(\n      map(\n        ([next, exact, includeSearchOptions, includeHashOptions, location]) => {\n          if (!next) return false\n          if (exact) {\n            const testExact = exactPathTest(\n              location.pathname,\n              next.pathname,\n              this.router.basepath,\n            )\n            if (!testExact) return false\n          } else {\n            const currentPathSplit = removeTrailingSlash(\n              location.pathname,\n              this.router.basepath,\n            ).split('/')\n            const nextPathSplit = removeTrailingSlash(\n              next.pathname,\n              this.router.basepath,\n            ).split('/')\n            const pathIsFuzzyEqual = nextPathSplit.every(\n              (d, i) => d === currentPathSplit[i],\n            )\n            if (!pathIsFuzzyEqual) {\n              return false\n            }\n          }\n\n          const includeSearch = includeSearchOptions ?? true\n          if (includeSearch) {\n            const searchTest = deepEqual(location.search, next.search, {\n              partial: !exact,\n              ignoreUndefined: !(includeSearchOptions ?? true),\n            })\n            if (!searchTest) {\n              return false\n            }\n          }\n\n          const includeHash = includeHashOptions ?? true\n          if (includeHash) {\n            return location.hash === next.hash\n          }\n\n          return true\n        },\n      ),\n    ),\n  )\n  protected activeClass = computed(() =>\n    this.isActive() ? this.activeOptions().class || 'active' : '',\n  )\n\n  constructor() {\n    afterRenderEffect(() => {\n      const [disabled, preload] = [\n        untracked(this.disabled),\n        untracked(this.preload),\n      ]\n      if (!disabled && preload === 'render') {\n        this.doPreload()\n      }\n    })\n\n    afterRenderEffect((onCleanup) => {\n      const unsub = this.router.subscribe('onResolved', () => {\n        this.transitioning.set(false)\n      })\n      onCleanup(() => unsub())\n    })\n  }\n\n  protected handleClick(event: MouseEvent) {\n    if (this.type() === 'external') return\n\n    const [disabled, target] = [\n      this.disabled(),\n      this.hostElement.nativeElement.target,\n    ]\n\n    if (\n      disabled ||\n      this.isCtrlEvent(event) ||\n      event.defaultPrevented ||\n      (target && target !== '_self') ||\n      event.button !== 0\n    ) {\n      return\n    }\n\n    event.preventDefault()\n    this.transitioning.set(true)\n\n    this.router.navigate(this.navigateOptions() as any)\n  }\n\n  protected handleFocus() {\n    if (this.disabled() || this.type() === 'external') return\n    if (this.preload()) {\n      this.doPreload()\n    }\n  }\n\n  private preloadTimeout: ReturnType<typeof setTimeout> | null = null\n  protected handleMouseEnter() {\n    if (\n      this.disabled() ||\n      !this.preload() ||\n      this.isActive() ||\n      this.type() === 'external'\n    )\n      return\n\n    this.preloadTimeout = setTimeout(() => {\n      this.preloadTimeout = null\n      this.doPreload()\n    }, this.preloadDelay())\n  }\n\n  protected handleMouseLeave() {\n    if (this.disabled() || this.type() === 'external') return\n    if (this.preloadTimeout) {\n      clearTimeout(this.preloadTimeout)\n      this.preloadTimeout = null\n    }\n  }\n\n  private doPreload() {\n    this.router.preloadRoute(this.navigateOptions() as any).catch((err) => {\n      console.warn(err)\n      console.warn(preloadWarning)\n    })\n  }\n\n  private isCtrlEvent(e: MouseEvent) {\n    return e.metaKey || e.altKey || e.ctrlKey || e.shiftKey\n  }\n}\n\nexport type ValidateLinkOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TOptions = unknown,\n  TDefaultFrom extends string = string,\n> = Constrain<\n  TOptions,\n  Omit<\n    LinkOptions<\n      TRouter,\n      InferFrom<TOptions, TDefaultFrom>,\n      InferTo<TOptions>,\n      InferMaskFrom<TOptions>,\n      InferMaskTo<TOptions>\n    >,\n    'activeOptions'\n  > &\n    Partial<Omit<HTMLAnchorElement, 'search'>> & {\n      label?: string | (() => string)\n      activeOptions?: LinkOptions<\n        TRouter,\n        InferFrom<TOptions, TDefaultFrom>,\n        InferTo<TOptions>,\n        InferMaskFrom<TOptions>,\n        InferMaskTo<TOptions>\n      >['activeOptions'] & { class?: string }\n    }\n>\n\nexport type ValidateLinkOptionsArray<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TOptions extends ReadonlyArray<any> = ReadonlyArray<unknown>,\n  TDefaultFrom extends string = string,\n> = {\n  [K in keyof TOptions]: ValidateLinkOptions<TRouter, TOptions[K], TDefaultFrom>\n}\n\nexport type LinkOptionsFnOptions<\n  TOptions,\n  TRouter extends AnyRouter = RegisteredRouter,\n> =\n  TOptions extends ReadonlyArray<any>\n    ? ValidateLinkOptionsArray<TRouter, TOptions>\n    : ValidateLinkOptions<TRouter, TOptions>\n\nexport type LinkOptionsFn = <\n  const TOptions,\n  TRouter extends AnyRouter = RegisteredRouter,\n>(\n  options: LinkOptionsFnOptions<TOptions, TRouter>,\n) => TOptions\n\nexport const linkOptions: LinkOptionsFn = (options) => {\n  return options as any\n}\n", "import {\n  Directive,\n  Injector,\n  assertInInjectionContext,\n  computed,\n  inject,\n  input,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toObservable, toSignal } from '@angular/core/rxjs-interop'\nimport { combineLatest, map, switchMap } from 'rxjs'\nimport { Link } from './link'\nimport { injectRouter } from './router'\nimport { routerState$ } from './router-state'\n\nimport type {\n  AnyRouter,\n  DeepPartial,\n  MakeOptionalPathParams,\n  MakeOptionalSearchParams,\n  MaskOptions,\n  RegisteredRouter,\n  MatchRouteOptions as TanstackMatchRouteOptions,\n  ToSubOptionsProps,\n} from '@tanstack/router-core'\n\nexport type MatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = ToSubOptionsProps<TRouter, TFrom, TTo> &\n  DeepPartial<MakeOptionalSearchParams<TRouter, TFrom, TTo>> &\n  DeepPartial<MakeOptionalPathParams<TRouter, TFrom, TTo>> &\n  MaskOptions<TRouter, TMaskFrom, TMaskTo> &\n  TanstackMatchRouteOptions & { injector?: Injector }\n\nexport function matchRoute$<TRouter extends AnyRouter = RegisteredRouter>({\n  injector,\n}: { injector?: Injector } = {}) {\n  !injector && assertInInjectionContext(matchRoute$)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    const router = injectRouter()\n    const status$ = routerState$({ select: (s) => s.status })\n\n    return <\n      const TFrom extends string = string,\n      const TTo extends string | undefined = undefined,\n      const TMaskFrom extends string = TFrom,\n      const TMaskTo extends string = '',\n    >(\n      opts: MatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ) => {\n      const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts\n      return status$.pipe(\n        map(() =>\n          router.matchRoute(rest as any, {\n            pending,\n            caseSensitive,\n            fuzzy,\n            includeSearch,\n          }),\n        ),\n      )\n    }\n  })\n}\n\nexport function matchRoute<TRouter extends AnyRouter = RegisteredRouter>({\n  injector,\n}: { injector?: Injector } = {}) {\n  !injector && assertInInjectionContext(matchRoute)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    const matchRoute$Return = matchRoute$({ injector })\n    return <\n      const TFrom extends string = string,\n      const TTo extends string | undefined = undefined,\n      const TMaskFrom extends string = TFrom,\n      const TMaskTo extends string = '',\n    >(\n      opts: MatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ) => {\n      return toSignal(matchRoute$Return(opts as any), { injector })\n    }\n  })\n}\n\nexport type MakeMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = MatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n\n@Directive({ selector: '[match]', exportAs: 'matchRoute' })\nexport class MatchRoute<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string = string,\n  const TTo extends string | undefined = undefined,\n  const TMaskFrom extends string = TFrom,\n  const TMaskTo extends string = '',\n> {\n  matchRoute = input<\n    Partial<MakeMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>>\n  >({}, { alias: 'match' })\n\n  private status$ = routerState$({ select: (s) => s.status })\n  private matchRouteFn = matchRoute$<TRouter>()\n\n  private parentLink = inject(Link, { optional: true })\n  private options = computed(() => {\n    const parentLinkOptions = this.parentLink?.linkOptions()\n    if (!parentLinkOptions) return this.matchRoute()\n    return { ...parentLinkOptions, ...this.matchRoute() }\n  })\n\n  match$ = combineLatest([toObservable(this.options), this.status$]).pipe(\n    switchMap(([matchRoute]) => this.matchRouteFn(matchRoute as any)),\n  )\n  match = toSignal(this.match$)\n}\n", "import warning from 'tiny-warning'\nimport { loaderData, loaderData$ } from './loader-data'\nimport { loaderDeps, loaderDeps$ } from './loader-deps'\nimport { match, match$ } from './match'\nimport { params, params$ } from './params'\nimport { createRoute } from './route'\nimport { routeContext, routeContext$ } from './route-context'\nimport { search, search$ } from './search'\n\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouter,\n  Constrain,\n  ConstrainLiteral,\n  FileBaseRouteOptions,\n  FileRoutesByPath,\n  LazyRouteOptions,\n  RegisteredRouter,\n  ResolveParams,\n  RouteById,\n  RouteConstraints,\n  RouteIds,\n  RouteLoaderFn,\n  UpdatableRouteOptions,\n} from '@tanstack/router-core'\nimport type { LoaderDataRoute } from './loader-data'\nimport type { LoaderDepsRoute } from './loader-deps'\nimport type { MatchRoute } from './match'\nimport type { ParamsRoute } from './params'\nimport type { Route } from './route'\nimport type { RouteContextRoute } from './route-context'\nimport type { SearchRoute } from './search'\n\nexport function createFileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = FileRoutesByPath[TFilePath]['id'],\n  TPath extends RouteConstraints['TPath'] = FileRoutesByPath[TFilePath]['path'],\n  TFullPath extends\n    RouteConstraints['TFullPath'] = FileRoutesByPath[TFilePath]['fullPath'],\n>(\n  path: TFilePath,\n): FileRoute<TFilePath, TParentRoute, TId, TPath, TFullPath>['createRoute'] {\n  return new FileRoute<TFilePath, TParentRoute, TId, TPath, TFullPath>(path, {\n    silent: true,\n  }).createRoute\n}\n\n/**\n @deprecated It's no longer recommended to use the `FileRoute` class directly.\n  Instead, use `createFileRoute('/path/to/file')(options)` to create a file route.\n */\nexport class FileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = FileRoutesByPath[TFilePath]['id'],\n  TPath extends RouteConstraints['TPath'] = FileRoutesByPath[TFilePath]['path'],\n  TFullPath extends\n    RouteConstraints['TFullPath'] = FileRoutesByPath[TFilePath]['fullPath'],\n> {\n  silent?: boolean\n\n  constructor(\n    public path: TFilePath,\n    _opts?: { silent: boolean },\n  ) {\n    this.silent = _opts?.silent\n  }\n\n  createRoute = <\n    TSearchValidator = undefined,\n    TParams = ResolveParams<TPath>,\n    TRouteContextFn = AnyContext,\n    TBeforeLoadFn = AnyContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderFn = undefined,\n    TChildren = unknown,\n  >(\n    options?: FileBaseRouteOptions<\n      TParentRoute,\n      TId,\n      TPath,\n      TSearchValidator,\n      TParams,\n      TLoaderDeps,\n      TLoaderFn,\n      AnyContext,\n      TRouteContextFn,\n      TBeforeLoadFn\n    > &\n      UpdatableRouteOptions<\n        TParentRoute,\n        TId,\n        TFullPath,\n        TParams,\n        TSearchValidator,\n        TLoaderFn,\n        TLoaderDeps,\n        AnyContext,\n        TRouteContextFn,\n        TBeforeLoadFn\n      >,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TFilePath,\n    TId,\n    TSearchValidator,\n    TParams,\n    AnyContext,\n    TRouteContextFn,\n    TBeforeLoadFn,\n    TLoaderDeps,\n    TLoaderFn,\n    TChildren,\n    unknown\n  > => {\n    warning(\n      this.silent,\n      'FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead.',\n    )\n    const route = createRoute(options as any)\n    ;(route as any).isRoot = false\n    return route as any\n  }\n}\n\n/**\n @deprecated It's recommended not to split loaders into separate files.\n  Instead, place the loader function in the the main route file, inside the\n  `createFileRoute('/path/to/file)(options)` options.\n */\nexport function FileRouteLoader<\n  TFilePath extends keyof FileRoutesByPath,\n  TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute'],\n>(\n  _path: TFilePath,\n): <TLoaderFn>(\n  loaderFn: Constrain<\n    TLoaderFn,\n    RouteLoaderFn<\n      TRoute['parentRoute'],\n      TRoute['types']['id'],\n      TRoute['types']['params'],\n      TRoute['types']['loaderDeps'],\n      TRoute['types']['routerContext'],\n      TRoute['types']['routeContextFn'],\n      TRoute['types']['beforeLoadFn']\n    >\n  >,\n) => TLoaderFn {\n  warning(\n    false,\n    `FileRouteLoader is deprecated and will be removed in the next major version. Please place the loader function in the the main route file, inside the \\`createFileRoute('/path/to/file')(options)\\` options`,\n  )\n  return (loaderFn) => loaderFn as any\n}\n\nexport class LazyRoute<TRoute extends AnyRoute> {\n  options: {\n    id: string\n  } & LazyRouteOptions\n\n  constructor(\n    opts: {\n      id: string\n    } & LazyRouteOptions,\n  ) {\n    this.options = opts\n  }\n\n  match$: MatchRoute<true, TRoute['id']> = (opts) =>\n    match$({ ...opts, from: this.options.id } as any) as any\n  match: MatchRoute<false, TRoute['id']> = (opts) =>\n    match({ ...opts, from: this.options.id } as any) as any\n\n  routeContext$: RouteContextRoute<true, TRoute['id']> = (opts) =>\n    routeContext$({ ...opts, from: this.options.id } as unknown as any)\n  routeContext: RouteContextRoute<false, TRoute['id']> = (opts) =>\n    routeContext({ ...opts, from: this.options.id } as unknown as any)\n\n  search$: SearchRoute<true, TRoute['id']> = (opts) =>\n    search$({ ...opts, from: this.options.id } as any) as any\n  search: SearchRoute<false, TRoute['id']> = (opts) =>\n    search({ ...opts, from: this.options.id } as any) as any\n\n  params$: ParamsRoute<true, TRoute['id']> = (opts) =>\n    params$({ ...opts, from: this.options.id } as any) as any\n  params: ParamsRoute<false, TRoute['id']> = (opts) =>\n    params({ ...opts, from: this.options.id } as any) as any\n\n  loaderDeps$: LoaderDepsRoute<true, TRoute['id']> = (opts) =>\n    loaderDeps$({ ...opts, from: this.options.id } as any)\n  loaderDeps: LoaderDepsRoute<false, TRoute['id']> = (opts) =>\n    loaderDeps({ ...opts, from: this.options.id } as any)\n\n  loaderData$: LoaderDataRoute<true, TRoute['id']> = (opts) =>\n    loaderData$({ ...opts, from: this.options.id } as any)\n  loaderData: LoaderDataRoute<false, TRoute['id']> = (opts) =>\n    loaderData({ ...opts, from: this.options.id } as any)\n}\n\nexport function createLazyRoute<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TId extends string = string,\n  TRoute extends AnyRoute = RouteById<TRouter['routeTree'], TId>,\n>(id: ConstrainLiteral<TId, RouteIds<TRouter['routeTree']>>) {\n  return (opts: LazyRouteOptions) => {\n    return new LazyRoute<TRoute>({\n      id: id,\n      ...opts,\n    })\n  }\n}\nexport function createLazyFileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TRoute extends FileRoutesByPath[TFilePath]['preLoaderRoute'],\n>(id: TFilePath) {\n  return (opts: LazyRouteOptions) => new LazyRoute<TRoute>({ id, ...opts })\n}\n", "import {\n  Directive,\n  EnvironmentInjector,\n  effect,\n  inject,\n  input,\n} from '@angular/core'\nimport { Matches } from './matches'\nimport { injectRouter } from './router'\n\nimport type { Provider } from '@angular/core'\nimport type {\n  AnyRoute,\n  AnyRouter,\n  RegisteredRouter,\n  RouterOptions,\n} from '@tanstack/router-core'\nimport type { NgRouter } from './router'\n\nexport type RouterRootOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouter['routeTree'],\n    NonNullable<TRouter['options']['trailingSlash']>,\n    false,\n    TRouter['history'],\n    TDehydrated\n  >,\n  'context'\n> & {\n  router: TRouter\n  context?: Partial<\n    RouterOptions<\n      TRouter['routeTree'],\n      NonNullable<TRouter['options']['trailingSlash']>,\n      false,\n      TRouter['history'],\n      TDehydrated\n    >['context']\n  >\n}\n\n@Directive({\n  selector: 'router-root,RouterRoot',\n  hostDirectives: [Matches],\n})\nexport class RouterRoot<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  router = input<RouterRootOptions<TRouter, TDehydrated>['router']>(\n    injectRouter() as unknown as TRouter,\n  )\n  options = input<Omit<RouterRootOptions<TRouter, TDehydrated>, 'router'>>({})\n\n  constructor() {\n    const environmentInjector = inject(EnvironmentInjector)\n    effect(() => {\n      const [router, options] = [this.router(), this.options()]\n      router.update({\n        ...router.options,\n        ...options,\n        context: {\n          ...router.options.context,\n          ...options.context,\n          getRouteInjector(routeId: string, providers: Array<Provider> = []) {\n            return (\n              router as unknown as NgRouter<AnyRoute>\n            ).getRouteEnvInjector(\n              routeId,\n              environmentInjector,\n              providers,\n              router,\n            )\n          },\n        },\n      })\n    })\n  }\n}\n", "import {\n  Injector,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toSignal } from '@angular/core/rxjs-interop'\nimport { routerState$ } from './router-state'\n\nexport function canGoBack$({ injector }: { injector?: Injector } = {}) {\n  !injector && assertInInjectionContext(canGoBack$)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return routerState$({\n      select: (s) => s.location.state.__TSR_index !== 0,\n      injector,\n    })\n  })\n}\n\nexport function canGoBack({ injector }: { injector?: Injector } = {}) {\n  !injector && assertInInjectionContext(canGoBack)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(canGoBack$({ injector }))\n  })\n}\n", "import {\n  Injector,\n  assertInInjectionContext,\n  inject,\n  runInInjectionContext,\n} from '@angular/core'\nimport { toSignal } from '@angular/core/rxjs-interop'\nimport { routerState$ } from './router-state'\n\nimport type { Signal } from '@angular/core'\nimport type {\n  AnyRouter,\n  RegisteredRouter,\n  RouterState,\n} from '@tanstack/router-core'\nimport type { Observable } from 'rxjs'\n\nexport interface LocationBaseOptions<TRouter extends AnyRouter, TSelected> {\n  select?: (state: RouterState<TRouter['routeTree']>['location']) => TSelected\n  injector?: Injector\n}\n\nexport type LocationResult<\n  TRouter extends AnyRouter,\n  TSelected,\n> = unknown extends TSelected\n  ? RouterState<TRouter['routeTree']>['location']\n  : TSelected\n\nexport function location$<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>({\n  injector,\n  select,\n}: LocationBaseOptions<TRouter, TSelected> = {}): Observable<\n  LocationResult<TRouter, TSelected>\n> {\n  !injector && assertInInjectionContext(location$)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return routerState$({\n      injector,\n      select: (state) => (select ? select(state.location) : state.location),\n    }) as Observable<LocationResult<TRouter, TSelected>>\n  })\n}\n\nexport function location<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n>({ injector, select }: LocationBaseOptions<TRouter, TSelected> = {}): Signal<\n  LocationResult<TRouter, TSelected>\n> {\n  !injector && assertInInjectionContext(location)\n\n  if (!injector) {\n    injector = inject(Injector)\n  }\n\n  return runInInjectionContext(injector, () => {\n    return toSignal(location$({ injector, select })) as Signal<\n      LocationResult<TRouter, TSelected>\n    >\n  })\n}\n", "/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],
  "mappings": "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",
  "names": ["distinctUntilRefChanged", "distinctUntilChanged", "Object", "is", "DefaultNotFound", "ɵcmp", "selectors", "hostAttrs", "decls", "vars", "template", "DefaultNotFound_Template", "rf", "ctx", "encapsulation", "changeDetection", "Component", "args", "selector", "ChangeDetectionStrategy", "OnPush", "host", "style", "isDevMode", "injector", "assertInInjectionContext", "inject", "Injector", "runInInjectionContext", "document", "DOCUMENT", "window", "defaultView", "ROUTER", "InjectionToken", "ROUTER_STATE", "injectRouter", "injectRouterState", "provideRouter", "router", "provide", "useValue", "useFactory", "state", "BehaviorSubject", "appRef", "ApplicationRef", "unsub", "__store", "subscribe", "currentVal", "next", "onDestroy", "complete", "asObservable", "createRouter", "options", "NgRouter", "RouterCore", "injectors", "Map", "envInjectors", "constructor", "getRouteInjector", "routeId", "parent", "providers", "existingInjector", "get", "create", "name", "set", "getRouteEnvInjector", "route", "routesById", "routesByPath", "push", "parentInjector", "parentRoute", "id", "envInjector", "createEnvironmentInjector", "rootRouteId", "forEach", "ele", "routerState$", "select", "equal", "shallow", "rootRouterState", "pipe", "map", "s", "routerState", "toSignal", "OnRendered", "match", "RouteMatch", "parentRouteId$", "combineLatest", "matchId$", "matches", "matchId", "find", "d", "location$", "resolvedLocation", "key", "subscription", "afterNextRender", "parentRouteId", "emit", "type", "getLocationChangeInfo", "DestroyRef", "unsubscribe", "Directive", "MATCH_ID", "input", "required", "vcr", "ViewContainerRef", "environmentInjector", "EnvironmentInjector", "toObservable", "resetKey$", "loadedAt", "toString", "matches$", "routeId$", "route$", "pendingComponent$", "pendingComponent", "defaultPendingComponent", "errorComponent$", "errorComponent", "defaultErrorComponent", "onCatch$", "onCatch", "defaultOnCatch", "matchIndex$", "findIndex", "matchState$", "matchIndex", "filter", "pick", "matchRoute$", "match$", "a", "b", "status", "matchLoad$", "withLatestFrom", "switchMap", "matchRoute", "loadPromise", "getMatch", "Promise", "resolve", "pendingMinMs", "defaultPendingMinMs", "minPendingPromise", "isServer", "createControlledPromise", "then", "updateMatch", "prev", "setTimeout", "undefined", "run$", "invariant", "isNotFound", "error", "notFoundCmp", "notFoundComponent", "defaultNotFoundComponent", "warning", "NOT_FOUND_COMPONENT_CONTEXT", "of", "component", "clearView", "isRedirect", "pendingCmp", "take", "errorCmp", "DefaultError", "ERROR_COMPONENT_CONTEXT", "info", "componentStack", "reset", "invalidate", "successComponent", "Outlet", "cmp", "cmpRef", "catchError", "throwError", "runData", "changeDetectorRef", "markForCheck", "clear", "createComponent", "Array", "isArray", "errorToThrow", "console", "hostVars", "hostBindings", "RouteMatch_HostBindings", "inputs", "features", "RouteMatch_Template", "hostDirectives", "parentGlobalNotFound$", "parentMatch", "globalNotFound", "childMatchId$", "index", "childMatchId", "renderedId", "parentGlobalNotFound", "setInput", "Outlet_Template", "opts", "closestMatchId", "optional", "nearestMatchId", "computed", "from", "shouldThrow", "loaderData$", "strict", "loaderData", "loaderDeps$", "rest", "loaderDeps", "params$", "params", "routeContext$", "routeContext", "context", "search$", "search", "routeApi", "RouteApi", "BaseRouteApi", "Route", "BaseRoute", "createRoute", "loader", "runFnInInjectionContext", "shouldReload", "beforeLoad", "createRootRouteWithContext", "createRootRoute", "RootRoute", "BaseRootRoute", "NotFoundRoute", "fn", "originalFn", "location", "routeInjector", "href", "bind", "show", "signal", "consts", "DefaultError_Template", "styles", "Transitioner", "destroyRef", "cdr", "ChangeDetectorRef", "hasPendingMatches$", "some", "isLoading$", "isLoading", "previousIsLoading$", "startWith", "pairwise", "curr", "isTransitioning$", "isAnyPending$", "isTransitioning", "hasPendingMatches", "previousIsAnyPending$", "isPagePending$", "previousIsPagePending$", "mountLoadForRouter", "mounted", "load$", "tap", "previousIsLoading", "setState", "pagePending$", "previousIsPagePending", "isPagePending", "pending$", "previousIsAnyPending", "isAnyPending", "hashScrollIntoViewOptions", "__hashScrollIntoViewOptions", "hash", "el", "getElementById", "scrollIntoView", "startTransition", "detectChanges", "Subscription", "untracked", "clientSsr", "tryLoad", "load", "err", "add", "ngOnInit", "history", "nextLocation", "buildLocation", "to", "latestLocation", "pathname", "_includeValidateSearch", "trimPathRight", "commitLocation", "replace", "Matches", "rootMatchId$", "rootMatchId", "pending", "ref", "parentMatches$", "closestMatch", "sliced", "slice", "parentMatches", "childMatches$", "childMatches", "Link", "linkOptions", "alias", "transform", "value", "linkActiveOptions", "class", "hostElement", "ElementRef", "currentSearch", "searchStr", "disabled", "userFrom", "userReloadDocument", "userPreload", "userPreloadDelay", "activeOptions", "exactActiveOptions", "exact", "includeHashActiveOptions", "includeHash", "includeSearchActiveOptions", "includeSearch", "URL", "length", "fullPath", "navigateOptions", "preload", "defaultPreload", "preloadDelay", "defaultPreloadDelay", "hostHref", "maskedLocation", "createHref", "transitioning", "isActive", "includeSearchOptions", "includeHashOptions", "testExact", "exactPathTest", "basepath", "currentPathSplit", "removeTrailingSlash", "split", "nextPathSplit", "pathIsFuzzyEqual", "every", "i", "searchTest", "deepEqual", "partial", "ignoreUndefined", "activeClass", "afterRenderEffect", "doPreload", "onCleanup", "handleClick", "event", "target", "nativeElement", "isCtrlEvent", "defaultPrevented", "button", "preventDefault", "navigate", "handleFocus", "preloadTimeout", "handleMouseEnter", "handleMouseLeave", "clearTimeout", "preloadRoute", "catch", "warn", "preloadWarning", "e", "metaKey", "altKey", "ctrlKey", "shiftKey", "Link_HostBindings", "$event", "Link_focus_HostBindingHandler", "Link_touchstart_HostBindingHandler", "Link_mouseenter_HostBindingHandler", "Link_mouseleave_HostBindingHandler", "exportAs", "status$", "caseSensitive", "fuzzy", "matchRoute$Return", "MatchRoute", "matchRouteFn", "parentLink", "parentLinkOptions", "createFileRoute", "path", "FileRoute", "silent", "_opts", "isRoot", "LazyRoute", "options", "constructor", "opts", "match$", "from", "id", "match", "routeContext$", "routeContext", "search$", "search", "params$", "params", "loaderDeps$", "loaderDeps", "loaderData$", "loaderData", "createLazyRoute", "createLazyFileRoute", "RouterRoot", "router", "input", "injectRouter", "environmentInjector", "inject", "EnvironmentInjector", "effect", "update", "context", "getRouteInjector", "routeId", "providers", "getRouteEnvInjector", "selectors", "inputs", "features", "Matches", "Directive", "args", "selector", "hostDirectives", "canGoBack$", "injector", "assertInInjectionContext", "Injector", "runInInjectionContext", "routerState$", "select", "s", "location", "state", "__TSR_index", "canGoBack", "toSignal", "location$"]
}
